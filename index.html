<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Dio‚Äôs Memory Keeper</title>
  <style>
    :root{
      --bg:#05050a;
      --card:#0f1022cc;
      --card2:#0f1022f2;
      --ui:#fff;
      --muted:#b9b9d6;
      --pink:#ff4fb3;
      --ghost:#a86a2a;
      --wall:#1b42ff;
      --glow:#69ffb7;
      --danger:#ff4d4d;
      --ok:#33d17a;
      --gold:#ffd700;
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    body{
      margin:0; color:var(--ui);
      background:radial-gradient(1200px 800px at 50% 20%, #141436 0%, var(--bg) 70%);
      overflow:hidden;
    }

    .layer{position:fixed; inset:0; display:none; place-items:center;}
    .layer.active{display:grid}

    .panel{
      position:relative;
      width:min(920px, calc(100vw - 28px));
      background:var(--card2);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:18px;
      box-shadow:0 24px 80px rgba(0,0,0,.65);
      backdrop-filter: blur(6px);
      overflow:hidden;
    }

    /* Subtle particle glow behind title */
    .particles{
      position:absolute; inset:0;
      pointer-events:none;
      opacity:0;
      transition:opacity 0.7s ease;
    }
    .particles.on{opacity:1}
    #particlesCanvas{width:100%; height:100%; display:block; opacity:.55; filter:blur(.2px);}

    .titleRow{
      position:relative;
      display:flex; align-items:center; justify-content:center;
      gap:10px;
      padding:10px 12px 6px;
      margin:2px 0 10px;
    }
    .title{
      font-weight:1000; letter-spacing:.9px;
      font-size:26px;
      margin:0;
      text-align:center;
      text-transform:uppercase;
    }
    .titleGlow{
      text-shadow:
        0 0 10px rgba(105,255,183,0.20),
        0 0 22px rgba(105,255,183,0.10);
    }

    .boxText{
      font-size:16px;
      line-height:1.55;
      color:#fff;
      white-space:pre-line;
      margin:0;
    }
    .boxText .muted{color:var(--muted); font-weight:800;}
    .divider{
      height:1px; background:rgba(255,255,255,.14);
      margin:12px 0;
    }

    .btnRow{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; margin-top:14px}
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background:#1b1c36;
      color:#fff;
      padding:11px 14px;
      border-radius:12px;
      cursor:pointer;
      font-weight:1000;
      transition:.15s transform, .25s box-shadow, .15s opacity;
      user-select:none;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn.primary{
      background:linear-gradient(135deg, #ff4fb3, #ff2d86);
      box-shadow:0 0 0 rgba(255,79,179,0);
    }
    .btn.primary:hover{box-shadow:0 0 18px rgba(255,79,179,0.28)}
    .btn.ghost{background:#10112a}
    .btn.ok{background:linear-gradient(135deg, #2fe17a, #14b85b)}
    .btn.danger{background:linear-gradient(135deg, #ff5c5c, #ff2b2b)}

    .pill{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 12px; border-radius:999px;
      background:var(--card); border:1px solid rgba(255,255,255,.12);
      color:var(--muted); font-weight:900;
      backdrop-filter: blur(8px);
      box-shadow:0 12px 30px rgba(0,0,0,.35);
    }
    .topBar{
      position:fixed; top:14px; left:14px; right:14px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      pointer-events:none;
      z-index:10;
    }
    .topBar .pill{pointer-events:auto}
    .tiny{font-size:12px; color:var(--muted); font-weight:800}

    #introCanvas, #endingCanvas{
      width:100vw; height:100vh;
      display:block;
      background:radial-gradient(1200px 800px at 50% 20%, #141436 0%, #04040a 70%);
    }

    /* Bottom clickable prompt (intro only) */
    .intro-bottom{
      position:fixed;
      left:0; right:0; bottom:10px;
      display:none;
      justify-content:center;
      z-index:50;
      pointer-events:none;
    }
    .intro-bottom.active{display:flex}
    .intro-bottom .inner{
      pointer-events:auto;
      background:rgba(15,16,34,0.90);
      border:1px solid rgba(255,255,255,0.16);
      border-radius:14px;
      padding:10px 12px;
      box-shadow:0 16px 50px rgba(0,0,0,0.6);
      backdrop-filter: blur(6px);
      display:flex;
      gap:10px;
      align-items:center;
      max-width:min(960px, calc(100vw - 22px));
    }
    .intro-bottom .tag{
      font-weight:1000;
      color:var(--muted);
      font-size:13px;
      white-space:nowrap;
    }
    .intro-bottom button{
      border:1px solid rgba(255,255,255,.18);
      background:linear-gradient(135deg, #ff4fb3, #ff2d86);
      color:#fff;
      padding:9px 12px;
      border-radius:12px;
      font-weight:1000;
      cursor:pointer;
    }
    .intro-bottom button.secondary{ background:#10112a; }

    .fadeOverlay{
      position:fixed; inset:0;
      background:#000;
      opacity:0;
      pointer-events:none;
      transition:opacity 0.8s ease;
      z-index:90;
    }
    .fadeOverlay.show{opacity:1}

    #gameWrap{position:fixed; inset:0; display:grid; place-items:center;}
    #gameCanvas{
      image-rendering:pixelated;
      border:2px solid #2a2a5a;
      border-radius:14px;
      box-shadow:0 20px 60px rgba(0,0,0,.6);
      background:#06060f;
    }

    /* GAME HUD */
    .hud{
      position:fixed; top:70px; left:14px; right:14px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      z-index:10;
      pointer-events:none;
      flex-wrap:wrap;
    }
    .hud .pill{pointer-events:none}
    .kbd{
      position:fixed; bottom:14px; left:14px;
      background:var(--card);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px 12px;
      color:var(--muted);
      font-size:13px; line-height:1.35;
      max-width:min(860px, calc(100vw - 28px));
      z-index:10;
      pointer-events:none;
    }
    .kbd b{color:#fff}

    /* Modal system (used in game + ending) */
    .modalOverlay{
      position:fixed; inset:0; display:none; place-items:center;
      background:rgba(0,0,0,.62);
      backdrop-filter: blur(6px);
      z-index:80;
    }
    .modal{
      width:min(760px, calc(100vw - 28px));
      max-height:min(86vh, 860px);
      overflow:auto;
      background:var(--card2);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:18px 18px 16px;
      box-shadow:0 24px 80px rgba(0,0,0,.65);
      position:relative;
    }
    .modal h2{margin:0 0 8px; font-size:20px}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between; margin-top:14px}
    .small{font-size:12px; color:var(--muted); font-weight:900}
    .optionGrid{display:grid; grid-template-columns:1fr; gap:10px; margin-top:10px}
    @media (min-width:560px){.optionGrid{grid-template-columns:1fr 1fr 1fr}}
    .optBtn{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:#0c0d1d;
      color:#fff;
      cursor:pointer;
      font-weight:1000;
      transition:.15s transform, .15s border-color;
    }
    .optBtn:hover{transform:translateY(-1px); border-color:rgba(255,255,255,.26)}
    .feedback{margin-top:10px; font-weight:1000}

    .ytWrap{width:100%; aspect-ratio:16/9; border-radius:14px; overflow:hidden; border:1px solid rgba(255,255,255,.14); background:#000;}
    .ytWrap iframe{width:100%; height:100%; border:0}
    .imgBox{
      width:100%; border-radius:14px; border:1px solid rgba(255,255,255,.14);
      background:#0c0d1d; overflow:hidden; aspect-ratio:16/9;
      display:grid; place-items:center; color:var(--muted); font-weight:1000;
    }
    .imgBox img{width:100%; height:100%; object-fit:cover}

    /* Congrats overlay (after level 2) */
    .winOverlay{
      position:fixed; inset:0;
      display:none;
      place-items:center;
      z-index:75;
      background:rgba(0,0,0,.45);
      backdrop-filter: blur(4px);
    }
    .winCard{
      position:relative;
      width:min(760px, calc(100vw - 28px));
      border-radius:18px;
      background:var(--card2);
      border:1px solid rgba(255,255,255,.14);
      padding:18px;
      box-shadow:0 24px 80px rgba(0,0,0,.65);
      text-align:center;
    }
    .winCard h1{ margin:0; font-size:24px; letter-spacing:.2px; }
    .winCard p{ margin:10px 0 0; color:var(--muted); font-weight:900; line-height:1.4 }
    .winCard .btnRow{justify-content:center}

    /* Confetti */
    .confettiFull{position:fixed; inset:0; pointer-events:none; z-index:76; display:none}

    .valOverlay{
      position:fixed; inset:0;
      display:none; place-items:center;
      background:rgba(4,4,12,.72);
      backdrop-filter:blur(6px);
      z-index:95;
      opacity:0;
      transition:opacity .45s ease;
    }
    .valOverlay.show{display:grid; opacity:1}
    .valCard{
      width:min(560px, calc(100vw - 26px));
      background:linear-gradient(180deg,#fff5fb,#ffe6f4);
      border-radius:20px;
      border:2px solid rgba(255,79,179,.34);
      box-shadow:0 24px 90px rgba(0,0,0,.45);
      padding:22px 18px 24px;
      color:#3e1630;
      position:relative;
      overflow:hidden;
    }
    .valEmoji{font-size:54px; text-align:center; margin:2px 0 8px}
    .valQuestionRow{display:flex; align-items:flex-end; justify-content:flex-end; gap:8px; margin-top:16px}
    .valQuestion{
      flex:1;
      font-family:'Pacifico','Great Vibes','Dancing Script',cursive;
      color:#e11d48;
      font-size:clamp(28px,5vw,40px);
      line-height:1.05;
      margin:0;
      text-align:center;
    }
    .valRose{font-size:22px; margin-bottom:5px}
    .valBtnWrap{position:relative; height:130px; margin-top:18px}
    .valBtn{position:absolute; min-width:120px; justify-content:center}
    #yesValBtn{left:calc(50% - 135px); top:20px}
    #noValBtn{left:calc(50% + 15px); top:20px; transition:left .18s ease, top .18s ease, transform .18s ease}

    .endingTitle{
      position:fixed; left:50%; bottom:26px;
      transform:translateX(-50%);
      z-index:88;
      font-weight:1000;
      color:#fff;
      background:rgba(15,16,34,.75);
      border:1px solid rgba(255,255,255,.2);
      border-radius:999px;
      padding:10px 18px;
      letter-spacing:.3px;
      display:none;
      animation:titlePulse 1.2s ease-in-out infinite alternate;
    }
    @keyframes titlePulse{from{transform:translateX(-50%) scale(1)}to{transform:translateX(-50%) scale(1.03)}}

    .inviteCard, .creditsCard{
      width:min(680px, calc(100vw - 24px));
      max-height:min(85vh, 860px);
      overflow:auto;
      background:rgba(255,255,255,.94);
      color:#2d1235;
      border-radius:20px;
      border:1px solid rgba(255,79,179,.35);
      box-shadow:0 20px 70px rgba(0,0,0,.38);
      padding:20px;
    }
    .inviteBody{white-space:pre-line; line-height:1.55; font-weight:800}

    .creditsCard{background:rgba(10,11,26,.95); color:#f7f1ff; text-align:center}
    .creditsScroll{
      overflow:hidden;
      height:min(52vh, 420px);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      margin-top:8px;
      position:relative;
      background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.06));
    }
    .creditsInner{
      position:absolute;
      left:0;
      right:0;
      padding:24px 16px;
      line-height:1.9;
      animation:creditsRoll 32s linear forwards;
    }
    .creditsInner p{margin:0 0 14px}
    @keyframes creditsRoll{
      from{transform:translateY(100%)}
      to{transform:translateY(-100%)}
    }

    .creditsNote{margin:10px 0 0; color:var(--muted); font-weight:900; font-size:13px}
  </style>
</head>
<body>

  <div class="topBar">
    <div class="pill">Progress: <span id="progressText">new</span></div>
    <div class="pill">
      <button class="btn ghost" id="resetBtn" style="pointer-events:auto; padding:7px 10px; border-radius:10px;">Reset Progress</button>
      <button class="btn ghost" id="muteBtn" style="pointer-events:auto; padding:7px 10px; border-radius:10px;">Music: On</button>
    </div>
  </div>

  <!-- INTRO -->
  <div class="layer active" id="introLayer" style="background:#000;">
    <canvas id="introCanvas"></canvas>
  </div>

  <!-- INTRO BOTTOM PROMPTS -->
  <div class="intro-bottom" id="introBottom">
    <div class="inner">
      <div class="tag" id="introBottomTag">A whisper‚Ä¶</div>
      <button id="helpBtn" style="display:none;">i think i can help</button>
      <button id="evansBtn" class="secondary" style="display:none;">It is I, the Goddest, Evans</button>
    </div>
  </div>

  <!-- MISSION PANEL -->
  <div class="layer" id="missionLayer">
    <div class="panel">
      <div class="particles" id="particlesWrap">
        <canvas id="particlesCanvas"></canvas>
      </div>

      <div class="titleRow">
        <h1 class="title titleGlow" id="mkTitle">üóùÔ∏è THE MEMORY KEEPER üóùÔ∏è</h1>
      </div>

      <p class="boxText" id="missionText"></p>

      <div class="btnRow">
        <button class="btn ghost" id="rulesBtn">What am I doing?</button>
        <button class="btn primary" id="letsGoBtn">Let‚Äôs Go ‚Üí</button>
      </div>

      <div class="tiny" style="margin-top:10px;">
        Tip: first click starts audio (browser rules). Music stays faint during gameplay.
      </div>
    </div>
  </div>

  <!-- GAME -->
  <div class="layer" id="gameLayer">
    <div id="gameWrap">
      <canvas id="gameCanvas"></canvas>
    </div>

    <div class="hud">
      <div class="pill">
        Level: <span id="hudLevel" style="color:#fff">1</span> ‚Ä¢
        Lives: <span id="hudLives" style="color:#fff">3</span>
      </div>
      <div class="pill">
        Collected: <span id="hudCollected" style="color:#fff">0/5</span> ‚Ä¢
        <span id="hudObjective">üîé Find 5 magnifying glasses</span>
      </div>
    </div>

    <div class="kbd">
      <b>Controls:</b> Arrow Keys / WASD ‚Ä¢ avoid the ghosts ‚Ä¢ collect items ‚Ä¢ reach the gate.
    </div>
  </div>

  <!-- ENDING CUTSCENES -->
  <div class="layer" id="endingLayer" style="background:#000;">
    <canvas id="endingCanvas"></canvas>
  </div>

  <div class="fadeOverlay" id="fade"></div>

  <!-- Q/A + content modal -->
  <div class="modalOverlay" id="modalOverlay">
    <div class="modal" id="modal">
      <h2 id="modalTitle">Title</h2>
      <div id="modalBody"></div>
      <div class="row">
        <div class="small" id="modalHint"></div>
        <button class="btn primary" id="doneBtn">Continue ‚ûú</button>
      </div>
    </div>
  </div>

  <!-- CONGRATS OVERLAY + CONFETTI -->
  <canvas class="confettiFull" id="confettiCanvas"></canvas>
  <div class="winOverlay" id="winOverlay">
    <div class="winCard">
      <h1 id="winTitle">Congrats üéâ</h1>
      <p id="winText">You‚Äôve successfully collected all memories and hearts that were once lost.</p>
      <div class="btnRow" style="margin-top:14px;">
        <button class="btn primary" id="continueBtn">Continue ‚Üí</button>
      </div>
      <div class="small" style="margin-top:10px;">(Next: the gate will finally open.)</div>
    </div>
  </div>

  <div class="endingTitle" id="endingTitle">‚ù§Ô∏è Cleo x Dio ‚ù§Ô∏è</div>

  <div class="valOverlay" id="valOverlay" aria-hidden="true">
    <div class="valCard" id="valCard">
      <div class="valEmoji">üíò</div>
      <div class="valQuestionRow">
        <p class="valQuestion">Will you be my Valentine?</p>
        <span class="valRose">üåπ</span>
      </div>
      <div class="valBtnWrap" id="valBtnWrap">
        <button class="btn ok valBtn" id="yesValBtn">Yes ‚ù§Ô∏è</button>
        <button class="btn danger valBtn" id="noValBtn">No üòü</button>
      </div>
    </div>
  </div>

  <div class="valOverlay" id="inviteOverlay" aria-hidden="true">
    <div class="inviteCard">
      <div class="inviteBody" id="inviteBody"></div>
      <div class="btnRow" style="justify-content:center; margin-top:16px">
        <button class="btn primary" id="inviteContinueBtn">Continue</button>
      </div>
    </div>
  </div>

  <div class="valOverlay" id="creditsOverlay" aria-hidden="true">
    <div class="creditsCard">
      <h2 style="margin:0">Rolling Credits</h2>
      <div class="creditsScroll">
        <div class="creditsInner" id="creditsInner"></div>
      </div>
      <p class="creditsNote">Tap <b>Done</b> to return to the celebration and click floating hearts for surprise memories.</p>
      <div class="btnRow" style="justify-content:center; margin-top:16px">
        <button class="btn primary" id="creditsDoneBtn">Done</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================================================
  // PERSISTENCE (progress + fixed maze seed so it DOESN'T change every time)
  // =========================================================
  const KEY = "dioMaze_progress_v3";
  const SEED_KEY = "dioMaze_seed_v3";     // fixed per user unless Reset Progress
  const LEVEL_KEY = "dioMaze_level_v3";   // resume level
  const LIVES_KEY = "dioMaze_lives_v3";
  const COLLECT_KEY = "dioMaze_collected_v3";
  const ITEMS_KEY = "dioMaze_items_v3";   // store collected flags
  const RNGSTEP_KEY = "dioMaze_rngstep_v3"; // keep randomness deterministic across sessions

  const Progress = {
    NEW: "new",
    INTRO_DONE: "intro_done",
    MISSION_SHOWN: "mission_shown",
    GAME_STARTED: "game_started",
    ENDING: "ending"
  };

  const progressText = document.getElementById("progressText");
  const getProgress = () => localStorage.getItem(KEY) || Progress.NEW;
  const setProgress = (v) => { localStorage.setItem(KEY, v); progressText.textContent = v; };

  function getOrCreateSeed(){
    const s = localStorage.getItem(SEED_KEY);
    if(s && /^\d+$/.test(s)) return Number(s)>>>0;
    const fresh = (Math.random()*0xFFFFFFFF)>>>0;
    localStorage.setItem(SEED_KEY, String(fresh));
    localStorage.setItem(RNGSTEP_KEY, "0");
    return fresh;
  }
  function resetAllPersistent(){
    [KEY, SEED_KEY, LEVEL_KEY, LIVES_KEY, COLLECT_KEY, ITEMS_KEY, RNGSTEP_KEY].forEach(k=>localStorage.removeItem(k));
  }

  // =========================================================
  // DOM
  // =========================================================
  const resetBtn = document.getElementById("resetBtn");
  const muteBtn = document.getElementById("muteBtn");

  const introLayer = document.getElementById("introLayer");
  const missionLayer = document.getElementById("missionLayer");
  const gameLayer = document.getElementById("gameLayer");
  const endingLayer = document.getElementById("endingLayer");

  const fade = document.getElementById("fade");
  const rulesBtn = document.getElementById("rulesBtn");
  const letsGoBtn = document.getElementById("letsGoBtn");

  const hudLevel = document.getElementById("hudLevel");
  const hudLives = document.getElementById("hudLives");
  const hudCollected = document.getElementById("hudCollected");
  const hudObjective = document.getElementById("hudObjective");

  // Intro bottom prompts
  const introBottom = document.getElementById("introBottom");
  const introBottomTag = document.getElementById("introBottomTag");
  const helpBtn = document.getElementById("helpBtn");
  const evansBtn = document.getElementById("evansBtn");

  // Modal
  const modalOverlay = document.getElementById("modalOverlay");
  const modalTitle = document.getElementById("modalTitle");
  const modalBody = document.getElementById("modalBody");
  const modalHint = document.getElementById("modalHint");
  const doneBtn = document.getElementById("doneBtn");

  // Congrats overlay + confetti
  const winOverlay = document.getElementById("winOverlay");
  const continueBtn = document.getElementById("continueBtn");
  const confettiCanvas = document.getElementById("confettiCanvas");
  const cctx = confettiCanvas.getContext("2d");

  const valOverlay = document.getElementById("valOverlay");
  const valCard = document.getElementById("valCard");
  const yesValBtn = document.getElementById("yesValBtn");
  const noValBtn = document.getElementById("noValBtn");
  const valBtnWrap = document.getElementById("valBtnWrap");
  const inviteOverlay = document.getElementById("inviteOverlay");
  const inviteBody = document.getElementById("inviteBody");
  const inviteContinueBtn = document.getElementById("inviteContinueBtn");
  const creditsOverlay = document.getElementById("creditsOverlay");
  const creditsInner = document.getElementById("creditsInner");
  const creditsDoneBtn = document.getElementById("creditsDoneBtn");
  const endingTitle = document.getElementById("endingTitle");

  function showLayer(layer){
    [introLayer, missionLayer, gameLayer, endingLayer].forEach(l=>l.classList.remove("active"));
    layer.classList.add("active");
  }
  function fadeTo(fn){
    fade.classList.add("show");
    setTimeout(()=>{ fn(); setTimeout(()=>fade.classList.remove("show"), 40); }, 650);
  }

  // =========================================================
  // SEEDED RNG (deterministic maze + item placement)
  // =========================================================
  function mulberry32(seed){
    let a = seed>>>0;
    return function(){
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  const BASE_SEED = getOrCreateSeed();
  let rngStep = Number(localStorage.getItem(RNGSTEP_KEY) || "0")|0;

  // We keep a deterministic rng per "context", but also store an advancing step
  // so gameplay randomness doesn't reshuffle the maze next time.
  function makeRngFor(tag, level){
    // hash: base seed + tag + level
    let h = BASE_SEED ^ (level*0x9E3779B9);
    for(let i=0;i<tag.length;i++){
      h = (h ^ tag.charCodeAt(i)) * 2654435761;
      h >>>= 0;
    }
    const r = mulberry32(h>>>0);
    // advance by rngStep to keep consistent between sessions
    for(let i=0;i<rngStep;i++) r();
    return r;
  }
  function rand01(r){
    const v = r();
    rngStep++;
    localStorage.setItem(RNGSTEP_KEY, String(rngStep));
    return v;
  }
  function randInt(r, a,b){
    return (a + rand01(r)*(b-a+1))|0;
  }

  // =========================================================
  // MISSION PANEL COPY
  // =========================================================
  const mkTitle = document.getElementById("mkTitle");
  const missionText = document.getElementById("missionText");

  const level1MissionTitle = "üóùÔ∏è THE MEMORY KEEPER üóùÔ∏è";
  const level1MissionCopy =
`His memories have been scattered deep within this maze. Five precious moments, lost and waiting to be found.

You've agreed to help. But memories must be verified before they can be reclaimed ‚Äî
<span class="muted">only correct answers unlock the truth.</span>

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ THE MISSION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üéÆ Navigate using arrow keys
üëª Avoid the shadow ghosts
üîç Find all 5 lost memories
‚úÖ Answer questions to verify each one
üíö Collect all 5 to unlock the exit

Then‚Ä¶ you‚Äôll enter the gate, and what‚Äôs waiting beyond it?
<span class="muted">Only one way to find out. üí≠</span>`;

  const level2MissionTitle = "üíù CUPID'S LOVE MAZE üíù";
  const level2MissionCopy =
`His memories have returned, but the gate remains sealed. Something is still missing.

The shadows scattered 5 pieces of his heart across this maze.
<span class="muted">Collect every heart to make him whole again.</span>

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ THE MISSION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üéÆ Navigate using arrow keys
üëª Avoid the shadow guardians
üíó Find all 5 heart pieces
‚ú® Discover what each heart reveals
üíö Collect all 5 to unlock the gate

Ready for the final search, CUPID?
<span class="muted">Only one way to find out. üí≠</span>`;

  function setMissionPanelForLevel(targetLevel){
    if(targetLevel===2){
      mkTitle.textContent = level2MissionTitle;
      missionText.innerHTML = level2MissionCopy;
      return;
    }
    mkTitle.textContent = level1MissionTitle;
    missionText.innerHTML = level1MissionCopy;
  }

  setMissionPanelForLevel(1);

  // =========================================================
  // AUDIO (Music + Evans voice fx + Ambient maze hum)
  // =========================================================
  let audioOn = true, audioStarted = false;
  let ac=null;

  // Music nodes
  let musicMaster=null, musicFilter=null, melodyTimer=null;

  // Ambient hum nodes
  let humGain=null, humFilter=null, humOsc1=null, humOsc2=null, humNoise=null, humNoiseGain=null;

  // Evans "echo voice" FX chain
  let evansInGain=null, evansFilter=null, evansDelay=null, evansFB=null, evansOutGain=null;

  function startAudioOnce(){
    if(audioStarted) return;
    audioStarted = true;
    ac = new (window.AudioContext || window.webkitAudioContext)();

    // ---- MUSIC
    musicMaster = ac.createGain(); musicMaster.gain.value = 0.18;
    musicFilter = ac.createBiquadFilter(); musicFilter.type="lowpass"; musicFilter.frequency.value=1200;
    musicFilter.connect(musicMaster).connect(ac.destination);

    const scale=[0,2,4,7,9], base=57;
    function playNote(midi, dur=0.55, vol=0.22){
      if(!audioOn) return;
      const t=ac.currentTime;
      const o1=ac.createOscillator(); o1.type="sine";
      o1.frequency.value=440*Math.pow(2,(midi-69)/12);
      const o2=ac.createOscillator(); o2.type="triangle";
      o2.frequency.value=o1.frequency.value*2; o2.detune.value=-6;
      const g=ac.createGain();
      g.gain.setValueAtTime(0.0001,t);
      g.gain.linearRampToValueAtTime(vol,t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
      o1.connect(g); o2.connect(g); g.connect(musicFilter);
      o1.start(t); o2.start(t);
      o1.stop(t+dur+0.02); o2.stop(t+dur+0.02);
    }
    let step=0;
    melodyTimer=setInterval(()=>{
      const deg=scale[step%scale.length];
      const midi=base+deg+(step%10===7?12:0);
      playNote(midi,0.6,0.22);
      step++;
    }, 560);

    // ---- HUM
    humGain = ac.createGain(); humGain.gain.value = 0.0001;
    humFilter = ac.createBiquadFilter(); humFilter.type="lowpass"; humFilter.frequency.value=420;

    humOsc1 = ac.createOscillator(); humOsc1.type="sine"; humOsc1.frequency.value=52;
    humOsc2 = ac.createOscillator(); humOsc2.type="triangle"; humOsc2.frequency.value=104; humOsc2.detune.value=-10;

    const noiseBuf = ac.createBuffer(1, ac.sampleRate*2, ac.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * 0.25;
    humNoise = ac.createBufferSource(); humNoise.buffer=noiseBuf; humNoise.loop=true;
    humNoiseGain = ac.createGain(); humNoiseGain.gain.value=0.14;

    const mix = ac.createGain(); mix.gain.value=0.6;
    humOsc1.connect(mix); humOsc2.connect(mix);
    humNoise.connect(humNoiseGain).connect(mix);
    mix.connect(humFilter).connect(humGain).connect(ac.destination);

    humOsc1.start(); humOsc2.start(); humNoise.start();

    // ---- EVANS FX chain
    evansInGain = ac.createGain(); evansInGain.gain.value=1;
    evansFilter = ac.createBiquadFilter(); evansFilter.type="bandpass"; evansFilter.frequency.value=900; evansFilter.Q.value=0.7;
    evansDelay  = ac.createDelay(1.0); evansDelay.delayTime.value=0.22;
    evansFB     = ac.createGain(); evansFB.gain.value=0.35;
    evansOutGain= ac.createGain(); evansOutGain.gain.value=0.35;

    evansDelay.connect(evansFB).connect(evansDelay);
    evansInGain.connect(evansFilter).connect(evansDelay).connect(evansOutGain).connect(ac.destination);
  }

  function setMusicVolume(mode){
    if(!musicMaster) return;
    if(mode==="intro")   musicMaster.gain.value = audioOn ? 0.16 : 0.00001;
    if(mode==="mission") musicMaster.gain.value = audioOn ? 0.18 : 0.00001;
    if(mode==="game")    musicMaster.gain.value = audioOn ? 0.12 : 0.00001;
    if(mode==="ending")  musicMaster.gain.value = audioOn ? 0.14 : 0.00001;
  }

  function rampHumTo(target, seconds){
    if(!humGain || !ac) return;
    const t = ac.currentTime;
    humGain.gain.cancelScheduledValues(t);
    humGain.gain.setValueAtTime(humGain.gain.value, t);
    humGain.gain.linearRampToValueAtTime(target, t + seconds);
  }

  function evansWhisper(){
    if(!ac) return;
    const t = ac.currentTime;
    const osc = ac.createOscillator();
    osc.type="sine";
    osc.frequency.setValueAtTime(520, t);
    osc.frequency.exponentialRampToValueAtTime(260, t+0.24);
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.12, t+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.32);
    osc.connect(g).connect(evansInGain);
    osc.start(t);
    osc.stop(t+0.34);
  }

  function playAttackSfx(){
    if(!ac || !audioOn) return;
    const t = ac.currentTime;
    const osc = ac.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(180, t);
    osc.frequency.exponentialRampToValueAtTime(70, t+0.2);
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.2, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.24);
    osc.connect(g).connect(ac.destination);
    osc.start(t);
    osc.stop(t+0.26);
  }

  function playHeartUnlockSfx(){
    if(!ac || !audioOn) return;
    const t = ac.currentTime;
    const osc1 = ac.createOscillator();
    const osc2 = ac.createOscillator();
    const filt = ac.createBiquadFilter();
    const g = ac.createGain();

    osc1.type = "sine";
    osc2.type = "triangle";
    osc1.frequency.setValueAtTime(420, t);
    osc1.frequency.exponentialRampToValueAtTime(760, t+0.24);
    osc2.frequency.setValueAtTime(630, t);
    osc2.frequency.exponentialRampToValueAtTime(980, t+0.24);

    filt.type = "lowpass";
    filt.frequency.setValueAtTime(2200, t);

    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.11, t+0.03);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.48);

    osc1.connect(filt);
    osc2.connect(filt);
    filt.connect(g).connect(ac.destination);

    osc1.start(t);
    osc2.start(t);
    osc1.stop(t+0.5);
    osc2.stop(t+0.5);
  }

  muteBtn.addEventListener("click",()=>{
    audioOn=!audioOn;
    muteBtn.textContent=`Music: ${audioOn?"On":"Off"}`;
    if(musicMaster) musicMaster.gain.value = audioOn ? musicMaster.gain.value : 0.00001;
    if(humGain && !audioOn) rampHumTo(0.0001, 0.25);
  });

  // =========================================================
  // PARTICLES (Mission title)
  // =========================================================
  const particlesWrap = document.getElementById("particlesWrap");
  const pCanvas = document.getElementById("particlesCanvas");
  const pctx = pCanvas.getContext("2d");
  let particles=[], pLast=performance.now();

  function resizeParticles(){
    const rect = particlesWrap.getBoundingClientRect();
    pCanvas.width = Math.max(1, Math.floor(rect.width));
    pCanvas.height= Math.max(1, Math.floor(rect.height));
  }
  function spawnParticles(){
    particles=[];
    for(let i=0;i<70;i++){
      particles.push({
        x: Math.random()*pCanvas.width,
        y: Math.random()*pCanvas.height,
        r: 0.8 + Math.random()*2.1,
        a: 0.15 + Math.random()*0.55,
        vx: (-0.15 + Math.random()*0.30),
        vy: (-0.20 + Math.random()*0.35)
      });
    }
  }
  function particlesLoop(now){
    const dt = Math.min(0.03,(now-pLast)/1000); pLast=now;
    if(!particlesWrap.classList.contains("on")){
      requestAnimationFrame(particlesLoop);
      return;
    }
    pctx.clearRect(0,0,pCanvas.width,pCanvas.height);
    for(const p of particles){
      p.x += p.vx*60*dt;
      p.y += p.vy*60*dt;
      if(p.x<0) p.x+=pCanvas.width;
      if(p.x>pCanvas.width) p.x-=pCanvas.width;
      if(p.y<0) p.y+=pCanvas.height;
      if(p.y>pCanvas.height) p.y-=pCanvas.height;

      pctx.beginPath();
      pctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      pctx.fillStyle = `rgba(105,255,183,${p.a})`;
      pctx.fill();
    }
    requestAnimationFrame(particlesLoop);
  }
  function turnOnParticles(){
    particlesWrap.classList.add("on");
    resizeParticles();
    spawnParticles();
  }

  // =========================================================
  // SHARED DRAW HELPERS (intro + ending + game ghosts)
  // =========================================================
  function lerp(a,b,t){ return a+(b-a)*t; }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function easeInOut(t){ return t<0.5 ? 2*t*t : 1-Math.pow(-2*t+2,2)/2; }
  function easeOut(t){ return 1-Math.pow(1-t,3); }

  function roundRect(g,x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    g.beginPath();
    g.moveTo(x+rr,y);
    g.arcTo(x+w,y,x+w,y+h,rr);
    g.arcTo(x+w,y+h,x,y+h,rr);
    g.arcTo(x,y+h,x,y,rr);
    g.arcTo(x,y,x+w,y,rr);
    g.closePath();
  }

  function drawSpeechBubble(g, x, y, text){
    const padX=14;
    g.save();
    g.font="bold 18px system-ui, -apple-system, Segoe UI, Roboto";
    const w = g.measureText(text).width + padX*2;
    const h = 40;
    const bx = x - w/2;
    const by = y - 90;

    g.fillStyle="rgba(15,16,34,0.92)";
    g.strokeStyle="rgba(255,255,255,0.18)";
    g.lineWidth=2;

    roundRect(g, bx, by, w, h, 14);
    g.fill(); g.stroke();

    g.beginPath();
    g.moveTo(x-10, by+h);
    g.lineTo(x, by+h+14);
    g.lineTo(x+10, by+h);
    g.closePath();
    g.fill(); g.stroke();

    g.fillStyle="#fff";
    g.fillText(text, bx+padX, by+26);
    g.restore();
  }

  function drawGhostSprite(g,x,y,wiggle,shade,scale=1, pupilDx=0, pupilDy=0){
    const bob=Math.sin(wiggle)*1.6*scale;
    g.save();
    g.translate(x,y);
    g.scale(scale,scale);

    g.beginPath();
    g.arc(0,-2+bob,10.5,Math.PI,0);
    g.lineTo(10.5,10+bob);
    for(let i=0;i<4;i++){
      const sx=10.5 - i*7;
      g.quadraticCurveTo(sx-3.5,14+bob,sx-7,10+bob);
    }
    g.closePath();
    g.fillStyle=shade ? "#8f5b24" : "#a86a2a";
    g.fill();

    g.fillStyle="rgba(255,255,255,.9)";
    g.beginPath();
    g.ellipse(-4,-1+bob,3.2,4.2,0,0,Math.PI*2);
    g.ellipse( 4,-1+bob,3.2,4.2,0,0,Math.PI*2);
    g.fill();

    g.fillStyle="rgba(0,0,0,.85)";
    g.beginPath();
    g.arc(-4 + pupilDx,-1+bob + pupilDy,1.4,0,Math.PI*2);
    g.arc( 4 + pupilDx,-1+bob + pupilDy,1.4,0,Math.PI*2);
    g.fill();

    g.restore();
  }

  function drawDioPac(g, x, y, t, facingAngle, color="#ff4fb3", r=18){
    const mouth=0.45 + 0.10*Math.sin(t*0.02);
    g.save();
    g.translate(x,y);
    g.beginPath();
    g.moveTo(0,0);
    g.arc(0,0,r, facingAngle+mouth, facingAngle+(Math.PI*2-mouth));
    g.closePath();
    g.fillStyle=color;
    g.fill();
    g.beginPath(); g.arc(6,-6,3,0,Math.PI*2);
    g.fillStyle="rgba(255,255,255,.92)";
    g.fill();
    g.restore();
  }

  // Gate that matches intro vibe, with text like "ACCESS DENIED" / "YOU MAY ENTER"
  function drawGateCard(g, x, y, labelTop, labelBottom, shake=0, openAmt=0){
    g.save();
    g.translate(x + shake, y);

    // frame
    g.fillStyle="rgba(27,66,255,0.92)";
    g.fillRect(-18,-28,36,56);

    // interior
    g.fillStyle="rgba(0,0,0,0.95)";
    g.fillRect(-12,-22,24,44);

    // "door" that slides open to the side (simple)
    if(openAmt < 1){
      const doorW = 24 * (1-openAmt);
      g.fillStyle="rgba(15,16,34,0.95)";
      g.fillRect(-12, -22, doorW, 44);
      g.fillStyle="rgba(255,255,255,0.10)";
      g.fillRect(-12+2, -22+2, Math.max(0,doorW-4), 40);
    }

    if(labelTop || labelBottom){
      g.fillStyle="#ff4fb3";
      g.font="900 12px system-ui";
      g.textAlign="center";
      if(labelTop) g.fillText(labelTop, 0, -40);
      if(labelBottom) g.fillText(labelBottom, 0, -24);
    }
    g.restore();
  }

  // =========================================================
  // INTRO ANIMATION (kept)
  // =========================================================
  const introCanvas = document.getElementById("introCanvas");
  const ictx = introCanvas.getContext("2d");
  const endingCanvas = document.getElementById("endingCanvas");
  const ectx = endingCanvas.getContext("2d");

  function resizeFullCanvas(c){
    c.width=window.innerWidth;
    c.height=window.innerHeight;
  }
  function resizeAll(){
    resizeFullCanvas(introCanvas);
    resizeFullCanvas(endingCanvas);
  }

  window.addEventListener("resize", ()=>{
    resizeAll();
    if(missionLayer.classList.contains("active")){
      resizeParticles();
      spawnParticles();
    }
    fitGame();
    if(confettiRunning){
      confettiCanvas.width = window.innerWidth;
      confettiCanvas.height = window.innerHeight;
    }
  });
  resizeAll();

  function drawIntroBackground(w,h){
    ictx.fillStyle="#05050a";
    ictx.fillRect(0,0,w,h);

    ictx.strokeStyle="rgba(27,66,255,0.12)";
    ictx.lineWidth=2;
    const spacing=48;
    for(let y=spacing; y<h; y+=spacing){
      ictx.beginPath(); ictx.moveTo(0,y); ictx.lineTo(w,y); ictx.stroke();
    }
    for(let x=spacing; x<w; x+=spacing){
      ictx.beginPath(); ictx.moveTo(x,0); ictx.lineTo(x,h); ictx.stroke();
    }
  }

  function lineDuration(text){
    const base = 1.8;
    const perChar = 0.032;
    const cap = 3.2;
    return Math.min(cap, base + text.length * perChar);
  }

  function hideIntroBottom(){
    introBottom.classList.remove("active");
    helpBtn.style.display="none";
    evansBtn.style.display="none";
    introBottomTag.textContent="A whisper‚Ä¶";
  }
  function showHelpPrompt(){
    introBottom.classList.add("active");
    introBottomTag.textContent="A whisper at the bottom of the screen‚Ä¶";
    helpBtn.style.display="inline-block";
    evansBtn.style.display="none";
  }
  function showEvansOption(){
    introBottom.classList.add("active");
    introBottomTag.textContent="Choose a reply‚Ä¶";
    helpBtn.style.display="none";
    evansBtn.style.display="inline-block";
  }

  const IntroT = {
    dioToCenter: 3.2,

    // Ghost choreography state machine timing
    ghostsEnter: 2.8,
    dioPanics: 0.95,
    attack: 1.4,
    retreat: 2.6,

    fadeOut: 2.6,
    blackHold: 1.6,

    fadeInToGate: 1.1,
    walkToGate: 3.0,
    deniedHold: 3.0,

    reactionLines: [
      "Ahh, mane‚Ä¶",
      "They didn‚Äôt just hit me‚Ä¶",
      "They stole my precious memories too.",
      "Now I gotta go back into that maze and find them."
    ],

    retreatToLeftStop: 2.2,

    thinkLines: [
      "..........",
      "Going back through that maze‚Ä¶",
      "no map‚Ä¶ no clues‚Ä¶ just dead ends‚Ä¶",
      "This could take me years.",
      "If only some divine being out there could guide me‚Ä¶"
    ],

    afterHelpLines: [
      "Who‚Äôs voice is that?",
      "‚Ä¶the Evans?",
      "I‚Äôd heard stories of a Goddest who can locate hearts and memories‚Äî",
      "even when they‚Äôre scattered anywhere in the maze world‚Ä¶",
      "But I never thought I‚Äôd be the one to get that kind of divine help.",
      "I thank you, dear Goddest.",
      "Lead the way."
    ],

    finalExitFade: 2.2
  };

  const introState = {
    t0: performance.now(),
    dio: {x:-60, y:0, r:18, facing:0},
    g1:  {x:0, y:0, r:9, wig:0, shade:0},
    g2:  {x:0, y:0, r:9, wig:0, shade:1},
    pops: [],
    fade: 0,
    attackFlash: 0,

    choreo: {
      state: "ghosts_enter",
      panicFacingLeft: false,
      nextFlipAt: 0,
      attackTriggered: false
    },

    phase: "timeline",
    phaseStart: 0,
    afterHelpIndex: 0,
    afterHelpLineStart: 0
  };

  function spawnPops(dioX, dioY){
    introState.pops = [];
    const heartsCount = 5, glassesCount = 5;
    const total = heartsCount + glassesCount;

    const spawn = (kind, i) => {
      const ang = (Math.PI*2) * (i/total) + (Math.random()*0.20);
      const spd = 2.0 + Math.random()*1.6;
      introState.pops.push({
        kind,
        x: dioX, y: dioY,
        vx: Math.cos(ang)*spd,
        vy: Math.sin(ang)*spd - 1.8,
        a: 1,
        s: 0.95 + Math.random()*0.10
      });
    };

    for(let i=0;i<heartsCount;i++) spawn("heart", i);
    for(let i=0;i<glassesCount;i++) spawn("glass", heartsCount + i);
  }

  function drawHeart(g,x,y,s,a){
    g.save(); g.globalAlpha=a; g.translate(x,y); g.scale(s,s);
    g.beginPath();
    g.moveTo(0,6);
    g.bezierCurveTo(0,-2,-12,-2,-12,6);
    g.bezierCurveTo(-12,14,0,18,0,26);
    g.bezierCurveTo(0,18,12,14,12,6);
    g.bezierCurveTo(12,-2,0,-2,0,6);
    g.closePath();
    g.fillStyle="#ff4fb3";
    g.fill();
    g.restore();
  }
  function drawGlass(g,x,y,s,a){
    g.save(); g.globalAlpha=a; g.translate(x,y); g.scale(s,s);
    g.strokeStyle="rgba(255,255,255,0.95)";
    g.lineWidth=3;
    g.beginPath(); g.arc(0,0,10,0,Math.PI*2); g.stroke();
    g.lineWidth=4;
    g.beginPath(); g.moveTo(8,8); g.lineTo(18,18); g.stroke();
    g.restore();
  }

  function runIntroFrame(now){
    const w=introCanvas.width, h=introCanvas.height;
    drawIntroBackground(w,h);

    const midY = h*0.55;
    const dio = introState.dio;
    const g1  = introState.g1;
    const g2  = introState.g2;

    dio.y = midY;
    g1.wig += 0.20;
    g2.wig += 0.20;

    const dioEndX = w*0.50;
    const gateX = dioEndX + 210;
    const gateY = midY;

    let bubbleText = "";
    let showGate=false, showDenied=false, showGateLines=false, gateShake=0;

    // 6 inches from left edge ‚âà 576px; clamp for smaller screens
    const leftStopDesired = 576;
    const leftStopX = Math.min(leftStopDesired, Math.max(240, w*0.42));

    if(introState.phase === "timeline"){
      const tSec = (now - introState.t0) / 1000;

      const t0=0;
      const t1=t0+IntroT.dioToCenter;
      const choreoTotal = IntroT.ghostsEnter + IntroT.dioPanics + IntroT.attack + IntroT.retreat;
      const t2=t1+choreoTotal;
      const t3=t2+IntroT.fadeOut;
      const t4=t3+IntroT.blackHold;

      const t5=t4+IntroT.fadeInToGate;
      const t6=t5+IntroT.walkToGate;

      const reactionStarts=[];
      let reactionTotal=0;
      for(const line of IntroT.reactionLines){
        reactionStarts.push(reactionTotal);
        reactionTotal += lineDuration(line);
      }

      const t7=t6+IntroT.deniedHold;
      const t8=t7+reactionTotal;
      const t9=t8+IntroT.retreatToLeftStop;

      const dioNearGateX = gateX - (18 + dio.r + 2);
      const dioStartX = -60;

      const g1StartX = w + 90;
      const g2StartX = -90;
      const g1StartY = midY - 44;
      const g2StartY = midY + 44;

      // Keep the ghosts roughly ~2 inches from Dio before the attack.
      const g1NearX = dioEndX + 192;
      const g2NearX = dioEndX - 192;
      const g1NearY = midY - 14;
      const g2NearY = midY + 14;

      const g1AttackX = dioEndX + 4;
      const g2AttackX = dioEndX - 4;
      const g1AttackY = midY - 3;
      const g2AttackY = midY + 3;

      const g1ExitX = w + 140;
      const g2ExitX = -140;

      let drawGhosts = true;

      if(tSec < t1){
        const u = easeInOut(clamp((tSec-t0)/(t1-t0),0,1));
        dio.x = lerp(dioStartX, dioEndX, u);
        dio.facing = 0;

        g1.x = g1StartX; g1.y = g1StartY;
        g2.x = g2StartX; g2.y = g2StartY;

        introState.fade=0;
        introState.attackFlash = 0;
      }
      else if(tSec < t2){
        dio.x = dioEndX;
        const local = tSec - t1;

        if(local < IntroT.ghostsEnter){
          introState.choreo.state = "ghosts_enter";
          const u = easeInOut(clamp(local/IntroT.ghostsEnter,0,1));
          g1.x = lerp(g1StartX, g1NearX, u);
          g1.y = lerp(g1StartY, g1NearY, u);
          g2.x = lerp(g2StartX, g2NearX, u);
          g2.y = lerp(g2StartY, g2NearY, u);

          const lookInterval = lerp(540, 170, u);
          if(introState.choreo.nextFlipAt===0){
            introState.choreo.nextFlipAt = now + lookInterval;
            introState.choreo.panicFacingLeft = false;
          }
          if(now >= introState.choreo.nextFlipAt){
            introState.choreo.panicFacingLeft = !introState.choreo.panicFacingLeft;
            introState.choreo.nextFlipAt = now + lookInterval;
          }
          dio.facing = introState.choreo.panicFacingLeft ? Math.PI : 0;
          introState.attackFlash = 0;
          introState.choreo.attackTriggered = false;
        }
        else if(local < IntroT.ghostsEnter + IntroT.dioPanics){
          introState.choreo.state = "dio_panics";
          const panicElapsed = local - IntroT.ghostsEnter;
          const u = clamp(panicElapsed/IntroT.dioPanics,0,1);

          g1.x = lerp(g1NearX, g1AttackX + 18, easeInOut(u));
          g1.y = lerp(g1NearY, g1AttackY, easeOut(u));
          g2.x = lerp(g2NearX, g2AttackX - 18, easeInOut(u));
          g2.y = lerp(g2NearY, g2AttackY, easeOut(u));

          const flipInterval = lerp(240, 70, u);
          if(introState.choreo.nextFlipAt===0){
            introState.choreo.nextFlipAt = now + flipInterval;
          }
          if(now >= introState.choreo.nextFlipAt){
            introState.choreo.panicFacingLeft = !introState.choreo.panicFacingLeft;
            introState.choreo.nextFlipAt = now + flipInterval;
          }
          dio.facing = introState.choreo.panicFacingLeft ? Math.PI : 0;
          introState.attackFlash = 0;
        }
        else if(local < IntroT.ghostsEnter + IntroT.dioPanics + IntroT.attack){
          introState.choreo.state = "attack";
          const attackElapsed = local - IntroT.ghostsEnter - IntroT.dioPanics;
          const u = clamp(attackElapsed/IntroT.attack,0,1);

          g1.x = lerp(g1AttackX + 18, g1AttackX, easeInOut(u));
          g1.y = lerp(g1AttackY, g1AttackY, u);
          g2.x = lerp(g2AttackX - 18, g2AttackX, easeInOut(u));
          g2.y = lerp(g2AttackY, g2AttackY, u);
          dio.facing = 0;

          if(!introState.choreo.attackTriggered){
            introState.choreo.attackTriggered = true;
            spawnPops(dio.x, dio.y);
            playAttackSfx();
          }
          introState.attackFlash = lerp(0.85, 0.15, u);
        }
        else {
          introState.choreo.state = "retreat";
          const retreatElapsed = local - IntroT.ghostsEnter - IntroT.dioPanics - IntroT.attack;
          const u = easeInOut(clamp(retreatElapsed/IntroT.retreat,0,1));

          g1.x = lerp(g1AttackX, g1ExitX, u);
          g1.y = lerp(g1AttackY, midY - 68, easeOut(u));
          g2.x = lerp(g2AttackX, g2ExitX, u);
          g2.y = lerp(g2AttackY, midY + 68, easeOut(u));
          dio.facing = 0;
          introState.attackFlash = 0;

          for(const p of introState.pops){
            p.vy += 0.02;
            p.x += p.vx*0.9;
            p.y += p.vy*0.9;
            p.a *= 0.990;
          }
        }

        introState.fade = 0;
      }
      else if(tSec < t3){
        introState.choreo.state = "next";
        dio.x = dioEndX;
        dio.facing=0;

        const uFade = clamp((tSec-t2)/(t3-t2),0,1);
        introState.fade = uFade;
        drawGhosts=false;

        for(const p of introState.pops){
          p.vy += 0.02;
          p.x += p.vx*0.8;
          p.y += p.vy*0.8;
          p.a *= 0.986;
        }
      }
      else if(tSec < t4){
        introState.fade = 1;
        dio.x = dioEndX;
        drawGhosts=false;
      }
      else if(tSec < t5){
        const u = clamp((tSec-t4)/(t5-t4),0,1);
        introState.fade = 1-u;
        dio.x = dioEndX;
        drawGhosts=false;
        showGate=true;
      }
      else if(tSec < t6){
        const u = clamp((tSec-t5)/(t6-t5),0,1);
        introState.fade=0;
        dio.x = lerp(dioEndX, dioNearGateX, easeInOut(u));
        drawGhosts=false;
        showGate=true;
        if(u<0.55) bubbleText="I better get outta here while I can‚Ä¶";
      }
      else if(tSec < t7){
        introState.fade=0;
        dio.x = dioNearGateX;
        drawGhosts=false;
        showGate=true; showDenied=true;

        const tLocal = tSec - t6;
        if(tLocal < 0.55) gateShake = Math.sin(tLocal * 42) * 2.2;
        showGateLines = (tLocal >= 0.55);
      }
      else if(tSec < t8){
        introState.fade=0;
        dio.x = dioNearGateX;
        drawGhosts=false;
        showGate=true; showDenied=true; showGateLines=true;

        const tLocal = tSec - t7;
        let idx=0;
        for(let i=0;i<reactionStarts.length;i++){
          if(tLocal >= reactionStarts[i]) idx=i;
        }
        bubbleText = IntroT.reactionLines[idx];
      }
      else if(tSec < t9){
        const u = clamp((tSec-t8)/(t9-t8),0,1);
        introState.fade=0;
        dio.facing = Math.PI;
        dio.x = lerp(dioNearGateX, leftStopX, easeInOut(u));
        drawGhosts=false;
        showGate=true; showDenied=true; showGateLines=true;
      }
      else{
        introState.phase="help_wait";
        introState.phaseStart=now;
        hideIntroBottom();
      }

      if(drawGhosts){
        drawGhostSprite(ictx, g1.x, g1.y, g1.wig, g1.shade, 1.55);
        drawGhostSprite(ictx, g2.x, g2.y, g2.wig, g2.shade, 1.55);
      }
    }

    if(introState.phase==="help_wait"){
      dio.x = leftStopX;
      dio.facing = Math.PI;
      introState.fade=0;

      const elapsed = (now - introState.phaseStart)/1000;
      let cursor=0, current="";
      for(const line of IntroT.thinkLines){
        const dur=lineDuration(line);
        if(elapsed < cursor+dur){ current=line; break; }
        cursor+=dur;
      }
      if(current){
        bubbleText=current;
      } else {
        showHelpPrompt();
      }
    }

    if(introState.phase==="evans_wait"){
      dio.x = leftStopX;
      dio.facing = Math.PI;
      introState.fade=0;

      const elapsed=(now-introState.phaseStart)/1000;
      const ask="Who‚Äôs voice is that?";
      if(elapsed < lineDuration(ask)){
        bubbleText=ask;
      } else {
        showEvansOption();
      }
    }

    if(introState.phase==="after_help"){
      dio.x = leftStopX;
      dio.facing = Math.PI;
      introState.fade=0;

      const idx=introState.afterHelpIndex;
      const line=IntroT.afterHelpLines[idx]||"";
      bubbleText=line;

      const lineElapsed=(now-introState.afterHelpLineStart)/1000;
      const dur=lineDuration(line);

      if(lineElapsed>=dur){
        introState.afterHelpIndex++;
        introState.afterHelpLineStart=now;
        if(introState.afterHelpIndex >= IntroT.afterHelpLines.length){
          introState.phase="exit_fade";
          introState.phaseStart=now;
        }
      }
    }

    if(introState.phase==="exit_fade"){
      const u = clamp((now-introState.phaseStart)/(IntroT.finalExitFade*1000),0,1);
      dio.facing=Math.PI;
      dio.x = lerp(leftStopX, -160, easeInOut(u));
      introState.fade = easeInOut(u);
      if(u>=1){
        hideIntroBottom();
        setProgress(Progress.INTRO_DONE);
        fadeTo(()=>{
          showLayer(missionLayer);
          setMusicVolume("mission");
          turnOnParticles();
          setProgress(Progress.MISSION_SHOWN);
        });
        return;
      }
    }

    // Draw Dio
    drawDioPac(ictx, dio.x, dio.y, now, dio.facing, "#ff4fb3", 18);

    // Gate
    if(showGate){
      if(showDenied){
        drawGateCard(ictx, gateX, gateY, "ACCESS", "DENIED", gateShake, 0);
      }else{
        drawGateCard(ictx, gateX, gateY, "", "", gateShake, 0);
      }

      if(showGateLines){
        ictx.save();
        ictx.fillStyle="rgba(255,255,255,0.78)";
        ictx.font="800 12px system-ui";
        ictx.textAlign="center";
        ictx.fillText("Your heart is incomplete.", gateX, gateY + 54);
        ictx.fillText("Your memories are missing.", gateX, gateY + 70);
        ictx.restore();
      }
    }

    // Pops
    for(const p of introState.pops){
      if(p.kind==="heart") drawHeart(ictx, p.x, p.y, p.s, p.a);
      else drawGlass(ictx, p.x, p.y, p.s, p.a);
    }

    // Bubble
    if(bubbleText) drawSpeechBubble(ictx, dio.x, dio.y, bubbleText);

    if(introState.attackFlash>0){
      ictx.fillStyle = `rgba(0,0,0,${introState.attackFlash})`;
      ictx.fillRect(0,0,w,h);
    }

    // Fade overlay
    if(introState.fade>0){
      ictx.fillStyle=`rgba(0,0,0,${introState.fade})`;
      ictx.fillRect(0,0,w,h);
    }

    requestAnimationFrame(runIntroFrame);
  }

  // Intro interactions
  helpBtn.addEventListener("click", ()=>{
    startAudioOnce();
    setMusicVolume("intro");
    if(introState.phase !== "help_wait") return;
    hideIntroBottom();
    introState.phase="evans_wait";
    introState.phaseStart=performance.now();
  });
  evansBtn.addEventListener("click", ()=>{
    startAudioOnce();
    setMusicVolume("intro");
    evansWhisper();
    if(introState.phase !== "evans_wait") return;
    hideIntroBottom();
    introState.phase="after_help";
    introState.phaseStart=performance.now();
    introState.afterHelpIndex=0;
    introState.afterHelpLineStart=performance.now();
  });

  // =========================================================
  // MODAL SYSTEM (game + ending)
  // =========================================================
  let paused = false;
  let modalOnDone = null;

  function escapeHTML(str){
    return String(str)
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function showModal({title, bodyHTML, hint="", doneEnabled=true, onDone=null}){
    paused=true;
    modalTitle.textContent=title;
    modalBody.innerHTML=bodyHTML;
    modalHint.textContent=hint;
    doneBtn.disabled=!doneEnabled;
    modalOnDone=onDone;
    modalOverlay.style.display="grid";
  }
  function hideModal(){
    modalOverlay.style.display="none";
    paused=false;
    const iframe=modalBody.querySelector("iframe");
    if(iframe) iframe.src="about:blank";
    modalBody.innerHTML="";
    modalOnDone=null;
  }
  doneBtn.addEventListener("click",()=>{
    if(doneBtn.disabled) return;
    const cb=modalOnDone;
    hideModal();
    if(typeof cb==="function") cb();
  });

  // =========================================================
  // GAME: FULL MAZE + QUESTIONS + POPUPS (replaces mock maze)
  // =========================================================
  const TOTAL_ITEMS_PER_LEVEL = 5;

  // YOUR 5 MEMORY QUESTIONS (Level 1)
  const memoryClues = [
    {
      title:"üîé Memory 1/5",
      q:"When was our first date?",
      options:["November 2022","December 2022","February 2023"],
      correct:"December 2022"
    },
    {
      title:"üîé Memory 2/5",
      q:"Who was the first person to ask to be in a relationship?",
      options:["Me","You","Both of us"],
      correct:"You"
    },
    {
      title:"üîé Memory 3/5",
      q:"Before I started calling you ‚Äúbabe,‚Äù what did I call you?",
      options:["Dio","My little dirty girl","Big head"],
      correct:"Dio"
    },
    {
      title:"üîé Memory 4/5",
      q:"What was the second movie we ever watched together at the cinema?",
      options:["Ant-Man and the Wasp: Quantumania","Oppenheimer","Wonka"],
      correct:"Ant-Man and the Wasp: Quantumania"
    },
    {
      title:"üîé Memory 5/5",
      q:"What was a habit you had in 2023 that I told you I missed?",
      options:["Sending videos","Using my hands however you like","Making jokes"],
      correct:"Using my hands however you like"
    },
  ];

  // Level 2 popups (5 hearts)
  const level2Popups = [
    {
      type:"youtube",
      miniCaption:"this song lives in my head rent free when i think about you",
      title:"üéµ Eyedress ‚Äî She Looks Just Like A Dream",
      src:"https://www.youtube.com/embed/XSzMpmmmf9o?si=Wg8kwJ5Ob8e8uZ9W&autoplay=1"
    },
    {
      type:"image",
      title:"Us right here.(we need more photos together)",
      embedSrc:"https://www.canva.com/design/DAHBRW7P5Kk/ldNZ68493T_jcfM4RNWDHg/view?embed",
      linkHref:"https://www.canva.com/design/DAHBRW7P5Kk/ldNZ68493T_jcfM4RNWDHg/view?utm_content=DAHBRW7P5Kk&utm_campaign=designshare&utm_medium=embeds&utm_source=link",
      linkText:"Aesthetic Vintage Lifestyle Photo Collage",
      byline:"Cleon Jardine"
    },
    {
      type:"image",
      title:"The kind of pretty that makes me pause.",
      embedSrc:"https://www.canva.com/design/DAHBRllzkPg/raB1WKzczqQWbQhZx7csvw/view?embed",
      linkHref:"https://www.canva.com/design/DAHBRllzkPg/raB1WKzczqQWbQhZx7csvw/view?utm_content=DAHBRllzkPg&utm_campaign=designshare&utm_medium=embeds&utm_source=link",
      linkText:"Red Cute Love Heart Valentine Day Photo Collage",
      byline:"Cleon Jardine"
    },
    {
      type:"image",
      title:"Little truths I never want to forget.",
      embedSrc:"https://www.canva.com/design/DAHBRe38Lcw/Bn4ZmshFePlzZjtj3HE5vw/view?embed",
      linkHref:"https://www.canva.com/design/DAHBRe38Lcw/Bn4ZmshFePlzZjtj3HE5vw/view?utm_content=DAHBRe38Lcw&utm_campaign=designshare&utm_medium=embeds&utm_source=link",
      linkText:"Photo Collage Moodboard Couple Phone Wallpaper",
      byline:"Cleon Jardine",
      tall:true
    },
    { type:"letter", title:"My Love,", text:
`My Love,

I‚Äôve been thinking about how to put this into words, and honestly, I don‚Äôt even know if words can fully explain how I feel. But I‚Äôm going to try.

You‚Äôre my first real girlfriend. Not just in title, but in experience. My first real date. My first real Valentine. The first person I‚Äôve shared so many genuine, meaningful moments with. And when I say I don‚Äôt want that to change, I truly mean it. I don‚Äôt want to look back years from now and say ‚Äúthat was just a phase.‚Äù I want to look back and say, ‚Äúthat was the beginning of everything.‚Äù

I don‚Äôt feel like sharing these kinds of firsts with anyone else. I don‚Äôt want to build these memories with anyone else. I chose you, and I keep choosing you.

We‚Äôve had our hiccups. We‚Äôve had moments where things felt shaky at the start, or even at the end. We‚Äôve had times where it wasn‚Äôt perfect. But the truth is, I don‚Äôt care if it starts shaky or ends a little messy ‚Äî what matters to me is the process. The time in between. The laughs. The calm moments. The deep talks. The way it feels when we‚Äôre just together.

When I‚Äôm with you, I feel calm. Even when I‚Äôm stressed, your presence does something to me. It grounds me. It reminds me that I‚Äôm not alone in this. And I genuinely enjoy being around you. I enjoy looking at you. You‚Äôre so beautiful it actually catches me off guard sometimes. I hope you know that. To me, you‚Äôre my number one model. So yes ‚Äî keep sending those pictures. Don‚Äôt be shy. I love seeing you.

There have been times where fear creeps in. Times where I think about disconnecting just to avoid getting hurt. But every single time, I realize I‚Äôd rather risk being vulnerable with you than miss out on what we could become. I don‚Äôt want to miss out on loving you fully. I don‚Äôt want to miss out on us growing, understanding each other more, creating more memories, spending more time together.

I want more time with you. More experiences. More ‚Äúfirsts.‚Äù More comfort. More openness. I want us to be vulnerable with each other. To share our emotions instead of hiding them. To choose each other even when it‚Äôs hard.

I really love you. I truly do. And I hope this isn‚Äôt just my first Valentine‚Äôs with you ‚Äî I hope it‚Äôs the first of many. I hope you‚Äôll continue being my girlfriend, my partner, my person. Not just for now, but going forward.

You‚Äôre special to me in a way I don‚Äôt feel for anyone else. And I don‚Äôt want that to change.

P.S Cleo‚ù§Ô∏è` },
  ];

  const finalSecretLetter =
`Through the journey of memories and heartfelt moments, I realized something simple:

I want more days with you.
More laughs. More late talks. More ‚Äúremember when‚Ä¶‚Äù.

Will you be my Valentine? üíó`;


  // =========================
  // GAME CONFIG
  // =========================
  const tileSize = 24;
  const COLS = 31;
  const ROWS = 33;

  const playerSpeed = 120;
  const ghostSpeed  = 112;
  const fixedDt = 1/120;
  const maxSubSteps = 5;

  // 1 wall, 0 floor, 3 gate closed, 4 gate open
  let map = null;

  // =========================
  // CANVAS / CTX
  // =========================
  const gameCanvas=document.getElementById("gameCanvas");
  const gctx=gameCanvas.getContext("2d",{alpha:false});

  function fitGame(){
    gameCanvas.width=COLS*tileSize;
    gameCanvas.height=ROWS*tileSize;
    const maxW=Math.min(gameCanvas.width, window.innerWidth-24);
    const maxH=Math.min(gameCanvas.height, window.innerHeight-24);
    gameCanvas.style.width=maxW+"px";
    gameCanvas.style.height=maxH+"px";
  }

  // =========================
  // STATE
  // =========================
  let level = Number(localStorage.getItem(LEVEL_KEY) || "1")|0;
  if(level!==1 && level!==2) level=1;

  let lives = Number(localStorage.getItem(LIVES_KEY) || "3")|0;
  if(lives<1 || lives>9) lives=3;

  let collected = Number(localStorage.getItem(COLLECT_KEY) || "0")|0;
  if(collected<0 || collected>5) collected=0;

  let items = []; // {id, kind, x,y,r,collected}
  let hasWon = false;
  let awaitingLevel2Start = false;
  let pendingMazeStartLevel = 1;

  const player={x:0,y:0,r:9,dx:0,dy:0,nextDx:0,nextDy:0};

  const ghosts=[
    {x:0,y:0,r:9,dir:{dx:1,dy:0},wiggle:0,shade:0},
    {x:0,y:0,r:9,dir:{dx:-1,dy:0},wiggle:0,shade:1},
  ];

  const dirs=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];

  // timing
  let lastT = performance.now();
  let acc = 0;
  let anim = 0;

  // confetti
  let confettiRunning=false;
  let confetti=[];
  const confettiColors = ["#ff4fb3", "#ffd700", "#69ffb7", "#58a6ff", "#ff8c42", "#c77dff"];

  // =========================
  // MAP + COLLISION
  // =========================
  function tileAt(c,r){
    if(r<0||r>=ROWS||c<0||c>=COLS) return 1;
    return map[r][c];
  }
  function isWall(v){ return v===1 || v===3; }

  function circleHitsWall(nx, ny, r){
    const left=nx-r, right=nx+r, top=ny-r, bottom=ny+r;
    const c1=(left/tileSize)|0, c2=(right/tileSize)|0;
    const r1=(top/tileSize)|0,  r2=(bottom/tileSize)|0;
    if(isWall(tileAt(c1,r1))) return true;
    if(isWall(tileAt(c2,r1))) return true;
    if(isWall(tileAt(c1,r2))) return true;
    if(isWall(tileAt(c2,r2))) return true;
    return false;
  }

  function findGate(){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(map[r][c]===3 || map[r][c]===4) return {r,c};
      }
    }
    return null;
  }
  function setGateOpen(open){
    const g = findGate();
    if(!g) return;
    map[g.r][g.c] = open ? 4 : 3;
  }

  function updateHUD(){
    hudLevel.textContent = String(level);
    hudLives.textContent = String(lives);
    hudCollected.textContent = `${collected}/${TOTAL_ITEMS_PER_LEVEL}`;
    hudObjective.textContent = (level===1)
      ? `üîé Find ${TOTAL_ITEMS_PER_LEVEL} magnifying glasses`
      : `üíó Find ${TOTAL_ITEMS_PER_LEVEL} hearts`;
    localStorage.setItem(LEVEL_KEY, String(level));
    localStorage.setItem(LIVES_KEY, String(lives));
    localStorage.setItem(COLLECT_KEY, String(collected));
  }

  // =========================
  // MAZE GENERATION (seeded; stable)
  // =========================
  function blankWalls(){
    return Array.from({length:ROWS}, () => new Array(COLS).fill(1));
  }

  function carvePerfectMaze(rng){
    const g = blankWalls();
    const steps = [{dr:0,dc:2},{dr:0,dc:-2},{dr:2,dc:0},{dr:-2,dc:0}];
    const stack = [{r:1,c:1}];
    g[1][1]=0;

    function inBounds(r,c){ return r>0 && r<ROWS-1 && c>0 && c<COLS-1; }

    while(stack.length){
      const cur = stack[stack.length-1];
      const order = steps.slice();

      // seeded shuffle
      for(let i=order.length-1;i>0;i--){
        const j = (rand01(rng)*(i+1))|0;
        [order[i],order[j]]=[order[j],order[i]];
      }

      let moved=false;
      for(const s of order){
        const nr=cur.r+s.dr, nc=cur.c+s.dc;
        if(!inBounds(nr,nc)) continue;
        if(g[nr][nc]===1){
          g[cur.r+s.dr/2][cur.c+s.dc/2]=0;
          g[nr][nc]=0;
          stack.push({r:nr,c:nc});
          moved=true;
          break;
        }
      }
      if(!moved) stack.pop();
    }
    return g;
  }

  function addLoops(rng, g, knocks){
    for(let k=0;k<knocks;k++){
      const r = randInt(rng, 2, ROWS-3);
      const c = randInt(rng, 2, COLS-3);
      if(g[r][c]!==1) continue;
      const openN = (g[r-1][c]===0)+(g[r+1][c]===0)+(g[r][c-1]===0)+(g[r][c+1]===0);
      if(openN>=2) g[r][c]=0;
    }
  }

  function tinyHub(g){
    const cr=(ROWS/2)|0, cc=(COLS/2)|0;
    for(let r=cr-1;r<=cr+1;r++){
      for(let c=cc-1;c<=cc+1;c++){
        if(r>0&&r<ROWS-1&&c>0&&c<COLS-1) g[r][c]=0;
      }
    }
  }

  function placeGate(g){
    const gr = ROWS-2;
    const gc = (COLS/2)|0;
    g[gr][gc]=3;
    g[gr-1][gc]=0;
    g[gr-1][gc-1]=0;
    g[gr-1][gc+1]=0;
  }

  function buildLevelMaze(lvl){
    const rng = makeRngFor("maze", lvl);
    const g = carvePerfectMaze(rng);
    addLoops(rng, g, (lvl===1) ? 120 : 170);
    tinyHub(g);
    placeGate(g);
    return g;
  }

  // =========================
  // REACHABILITY + ITEMS (seeded; stable)
  // =========================
  function bfsDist(startR,startC){
    const dist = Array.from({length:ROWS}, () => new Array(COLS).fill(-1));
    const q = [[startR,startC]];
    dist[startR][startC]=0;
    let qi=0;
    while(qi<q.length){
      const [r,c]=q[qi++];
      for(const d of dirs){
        const nr=r+d.dy, nc=c+d.dx;
        if(nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
        if(dist[nr][nc]!==-1) continue;
        if(isWall(map[nr][nc])) continue;
        dist[nr][nc]=dist[r][c]+1;
        q.push([nr,nc]);
      }
    }
    return dist;
  }

  function pickFarthest(rng, dist, count){
    const cells=[];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(dist[r][c]>=0 && map[r][c]===0) cells.push({r,c,d:dist[r][c]});
      }
    }
    cells.sort((a,b)=>b.d-a.d);
    const top=cells.slice(0, Math.min(420, cells.length));

    const picks=[];
    const minSep = 9;
    for(const cell of top){
      let ok=true;
      for(const p of picks){
        if(Math.abs(p.r-cell.r)+Math.abs(p.c-cell.c) < minSep){ ok=false; break; }
      }
      if(ok){
        picks.push(cell);
        if(picks.length===count) break;
      }
    }
    while(picks.length<count && top.length) picks.push(top[picks.length]);
    // seeded tiny shuffle to avoid identical patterns while staying deterministic
    for(let i=picks.length-1;i>0;i--){
      const j=(rand01(rng)*(i+1))|0;
      [picks[i],picks[j]]=[picks[j],picks[i]];
    }
    return picks.slice(0,count);
  }

  function pickSpreadCollectibles(rng, dist, count){
    const spawnR = (player.y/tileSize)|0;
    const spawnC = (player.x/tileSize)|0;
    const walkable=[];

    for(let r=1;r<ROWS-1;r++){
      for(let c=1;c<COLS-1;c++){
        if(map[r][c]!==0 || dist[r][c] < 0) continue;
        walkable.push({r,c});
      }
    }

    function quadrantOf(cell){
      const top = cell.r < ROWS/2;
      const left = cell.c < COLS/2;
      if(top && left) return 0;
      if(top && !left) return 1;
      if(!top && left) return 2;
      return 3;
    }

    function farEnough(cell, chosen, minSep, minSpawn){
      const spawnDist = Math.abs(cell.r-spawnR)+Math.abs(cell.c-spawnC);
      if(spawnDist < minSpawn) return false;
      for(const p of chosen){
        const d = Math.abs(p.r-cell.r)+Math.abs(p.c-cell.c);
        if(d < minSep) return false;
      }
      return true;
    }

    const chosen=[];
    let minSep = 8;
    let minSpawn = 6;

    for(let relax=0; relax<4 && chosen.length<count; relax++){
      const byQuad=[[],[],[],[]];
      for(const cell of walkable){
        const q = quadrantOf(cell);
        byQuad[q].push(cell);
      }

      for(const quadCells of byQuad){
        for(let i=quadCells.length-1;i>0;i--){
          const j=(rand01(rng)*(i+1))|0;
          [quadCells[i],quadCells[j]]=[quadCells[j],quadCells[i]];
        }
        const found = quadCells.find(cell=>farEnough(cell, chosen, minSep, minSpawn));
        if(found && chosen.length<count) chosen.push(found);
      }

      const pool = walkable.slice();
      for(let i=pool.length-1;i>0;i--){
        const j=(rand01(rng)*(i+1))|0;
        [pool[i],pool[j]]=[pool[j],pool[i]];
      }
      for(const cell of pool){
        if(chosen.length>=count) break;
        if(farEnough(cell, chosen, minSep, minSpawn)) chosen.push(cell);
      }

      minSep = Math.max(3, minSep-2);
      minSpawn = Math.max(2, minSpawn-1);
    }

    while(chosen.length<count && walkable.length){
      chosen.push(walkable[(rand01(rng)*walkable.length)|0]);
    }

    return chosen.slice(0,count);
  }

  function resetPlayer(){
    player.x=1.5*tileSize;
    player.y=1.5*tileSize;
    player.dx=player.dy=player.nextDx=player.nextDy=0;
  }

  function spawnGhosts(){
    const rng = makeRngFor("ghostSpawn", level);

    const pr=(player.y/tileSize)|0, pc=(player.x/tileSize)|0;
    const dist=bfsDist(pr,pc);
    const spots=pickFarthest(rng, dist, 2);

    for(let i=0;i<2;i++){
      const s = spots[i] || {r:ROWS-3, c:(COLS/2)|0};
      ghosts[i].x=(s.c+0.5)*tileSize;
      ghosts[i].y=(s.r+0.5)*tileSize;
      ghosts[i].dir = dirs[(rand01(rng)*4)|0];
      ghosts[i].wiggle = rand01(rng)*Math.PI*2;
    }
  }

  function placeItems(){
    const rng = makeRngFor("items", level);

    const pr=(player.y/tileSize)|0, pc=(player.x/tileSize)|0;
    const dist=bfsDist(pr,pc);
    const spots=pickSpreadCollectibles(rng, dist, TOTAL_ITEMS_PER_LEVEL);

    items=[];
    collected=0;
    const kind = (level===1) ? "glass" : "heart";

    for(let i=0;i<TOTAL_ITEMS_PER_LEVEL;i++){
      const s=spots[i];
      items.push({
        id:i,
        kind,
        x:(s.c+0.5)*tileSize,
        y:(s.r+0.5)*tileSize,
        r:9,
        collected:false
      });
    }

    // Restore collected flags if present
    const saved = localStorage.getItem(ITEMS_KEY);
    if(saved){
      try{
        const parsed = JSON.parse(saved);
        if(parsed && parsed[level] && Array.isArray(parsed[level])){
          const flags = parsed[level];
          for(let i=0;i<items.length;i++){
            items[i].collected = !!flags[i];
            if(items[i].collected) collected++;
          }
        }
      }catch(e){}
    }

    setGateOpen(collected>=TOTAL_ITEMS_PER_LEVEL);
    updateHUD();
  }

  function saveItemFlags(){
    let obj = {};
    const saved = localStorage.getItem(ITEMS_KEY);
    if(saved){ try{ obj = JSON.parse(saved)||{}; }catch(e){ obj={}; } }
    obj[level] = items.map(it=>!!it.collected);
    localStorage.setItem(ITEMS_KEY, JSON.stringify(obj));
  }

  function clearItemFlagsForLevel(lvl){
    let obj = {};
    const saved = localStorage.getItem(ITEMS_KEY);
    if(saved){
      try{ obj = JSON.parse(saved)||{}; }catch(e){ obj={}; }
    }
    delete obj[lvl];
    localStorage.setItem(ITEMS_KEY, JSON.stringify(obj));
  }

  // =========================
  // INPUT
  // =========================
  const keys=new Set();
  function setIntendedDir(){
    let ndx=0, ndy=0;
    if(keys.has("ArrowLeft")||keys.has("a")||keys.has("A")) ndx=-1;
    else if(keys.has("ArrowRight")||keys.has("d")||keys.has("D")) ndx=1;
    else if(keys.has("ArrowUp")||keys.has("w")||keys.has("W")) ndy=-1;
    else if(keys.has("ArrowDown")||keys.has("s")||keys.has("S")) ndy=1;
    if(ndx||ndy){ player.nextDx=ndx; player.nextDy=ndy; }
  }
  window.addEventListener("keydown",(e)=>{
    const k=e.key;
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","w","a","s","d","W","A","S","D"].includes(k)) e.preventDefault();
    keys.add(k); setIntendedDir();
    startAudioOnce();
  });
  window.addEventListener("keyup",(e)=>keys.delete(e.key));

  // =========================
  // MODALS: Level 1 Q/A + Level 2 content
  // =========================
  function showClueModal(idx){
    const clue=memoryClues[idx] || memoryClues[memoryClues.length-1];
    const optionsHTML = clue.options.map(opt => `<button class="optBtn" data-opt="${escapeHTML(opt)}">${escapeHTML(opt)}</button>`).join("");
    showModal({
      title: clue.title,
      bodyHTML: `
        <p style="margin:0 0 8px; font-weight:1000; color:#fff">${escapeHTML(clue.q)}</p>
        <div class="optionGrid">${optionsHTML}</div>
        <div class="feedback" id="clueFeedback"></div>
        <p class="small" style="margin-top:10px">(Pick the correct option. You can‚Äôt continue until you do.)</p>
      `,
      hint:"Choose the right answer to continue",
      doneEnabled:false
    });

    const feedback=document.getElementById("clueFeedback");
    const btns=[...modalBody.querySelectorAll(".optBtn")];
    btns.forEach(b=>{
      b.addEventListener("click",()=>{
        const picked=b.getAttribute("data-opt");
        if(picked.toLowerCase()===clue.correct.toLowerCase()){
          feedback.textContent="Correct ‚úÖ";
          feedback.style.color="var(--ok)";
          doneBtn.disabled=false;
        } else {
          feedback.textContent="Not quite ‚Äî try again.";
          feedback.style.color="var(--danger)";
          doneBtn.disabled=true;
        }
      });
    });
  }

  function showLevel2Modal(idx){
    const data=level2Popups[idx] || level2Popups[level2Popups.length-1];

    if(data.type==="youtube"){
      const miniCaptionHTML = data.miniCaption
        ? `<p class="small" style="margin:0 0 8px; text-transform:uppercase; letter-spacing:.08em">${escapeHTML(data.miniCaption)}</p>`
        : "";
      showModal({
        title:"üíó Found a heart!",
        bodyHTML:`${miniCaptionHTML}<p style="margin:0 0 10px"><b>${escapeHTML(data.title)}</b></p>
          <div class="ytWrap"><iframe src="${data.src}" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>
          <p class="small" style="margin-top:10px">Click <b>Done</b> when you‚Äôre finished.</p>`,
        doneEnabled:true
      });
      return;
    }

    if(data.type==="image"){
      const safeEmbedSrc = escapeHTML(data.embedSrc||"");
      const safeLinkHref = escapeHTML(data.linkHref||"");
      const safeLinkText = escapeHTML(data.linkText||"Open Canva design");
      const safeByline = escapeHTML(data.byline||"");
      const padTop = data.tall ? "177.7778%" : "80.0000%";
      showModal({
        title:"üíó Found a heart!",
        bodyHTML:`
          <p style="margin:0 0 10px"><b>${escapeHTML(data.title)}</b></p>
          <div style="position: relative; width: 100%; height: 0; padding-top: ${padTop};
            padding-bottom: 0; box-shadow: 0 2px 8px 0 rgba(63,69,81,0.16); margin-top: 1.6em; margin-bottom: 0.9em; overflow: hidden;
            border-radius: 8px; will-change: transform;">
            <iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; border: none; padding: 0; margin: 0;"
              src="${safeEmbedSrc}" allowfullscreen="allowfullscreen" allow="fullscreen">
            </iframe>
          </div>
          <a href="${safeLinkHref}" target="_blank" rel="noopener noreferrer">${safeLinkText}</a>${safeByline ? ` by ${safeByline}` : ""}
          <p class="small" style="margin-top:10px">Click <b>Done</b> when you‚Äôre finished.</p>`,
        doneEnabled:true
      });
      return;
    }

    showModal({
      title:"üíó Found a heart!",
      bodyHTML:`<p style="margin:0 0 10px"><b>${escapeHTML(data.title)}</b></p>
        <div style="white-space:pre-wrap; background:#0c0d1d; border:1px solid rgba(255,255,255,.14);
          border-radius:14px; padding:14px; color:#fff; line-height:1.45; max-width:680px;
          margin:0 auto; font-family:'Dancing Script','Great Vibes','Pacifico',cursive; font-size:22px; text-align:center;">${escapeHTML(data.text)}</div>
        <p class="small" style="margin-top:10px">Click <b>Done</b> when you‚Äôre finished.</p>`,
      doneEnabled:true
    });
  }

  function showSecretLetter(){
    showModal({
      title:"üíå One last thing‚Ä¶",
      bodyHTML: `
        <div style="white-space:pre-wrap; background:#0c0d1d; border:1px solid rgba(255,255,255,.14);
          border-radius:14px; padding:14px; color:#fff; line-height:1.4">${escapeHTML(finalSecretLetter)}</div>

        <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap; position:relative;">
          <button class="btn ok" id="yesBtn">Yes üíó</button>
          <button class="btn danger" id="noBtn">No</button>
        </div>

        <div class="small" style="margin-top:10px">The ‚ÄúNo‚Äù button will try to escape.</div>
      `,
      hint:"Click ‚ÄúYes‚Äù",
      doneEnabled:false
    });

    const yesBtn = document.getElementById("yesBtn");
    const noBtn  = document.getElementById("noBtn");
    const container = noBtn.parentElement;

    function moveNo(){
      const pane = container.getBoundingClientRect();
      const b = noBtn.getBoundingClientRect();
      const pad = 6;
      const maxX = pane.width - b.width - pad;
      const maxY = 70;
      const x = pad + Math.random() * Math.max(10, maxX - pad);
      const y = pad + Math.random() * Math.max(10, maxY - pad);

      noBtn.style.position = "absolute";
      noBtn.style.left = x + "px";
      noBtn.style.top  = y + "px";
    }
    noBtn.addEventListener("mouseenter", moveNo);
    noBtn.addEventListener("click", moveNo);

    yesBtn.addEventListener("click", () => {
      doneBtn.disabled = false;
      modalHint.textContent = "Locked in üíó";
      yesBtn.disabled = true;
      noBtn.disabled = true;
      yesBtn.textContent = "YES üíó (Locked In)";
    });
  }

  // =========================
  // MOVEMENT
  // =========================
  function attemptTurn(){
    if(!(player.nextDx||player.nextDy)) return;
    const nx = player.x + player.nextDx * 2;
    const ny = player.y + player.nextDy * 2;
    if(!circleHitsWall(nx,ny,player.r)){
      player.dx=player.nextDx;
      player.dy=player.nextDy;
    }
  }
  function movePlayer(dt){
    attemptTurn();
    const nx=player.x + player.dx*playerSpeed*dt;
    const ny=player.y + player.dy*playerSpeed*dt;
    if(!circleHitsWall(nx,ny,player.r)){ player.x=nx; player.y=ny; }
    else { player.dx=0; player.dy=0; }
  }

  function chooseGhostDir(g){
    const tc=(g.x/tileSize)|0;
    const tr=(g.y/tileSize)|0;
    const cx=(tc+0.5)*tileSize;
    const cy=(tr+0.5)*tileSize;

    if(Math.abs(g.x-cx)>0.9 || Math.abs(g.y-cy)>0.9) return;

    g.x=cx; g.y=cy;

    const valid=[];
    for(const d of dirs){
      const nx=cx + d.dx*tileSize*0.55;
      const ny=cy + d.dy*tileSize*0.55;
      if(!circleHitsWall(nx,ny,g.r)) valid.push(d);
    }
    if(valid.length===0) return;

    const fwd=g.dir;
    const rev={dx:-fwd.dx, dy:-fwd.dy};

    const fwdOk = valid.some(d=>d.dx===fwd.dx && d.dy===fwd.dy);
    const atIntersection = valid.length >= 3;

    // seeded-ish: use Math.random lightly but doesn't affect maze. If you want fully deterministic, swap to rand01(makeRngFor("ghostMove", level)).
    const shouldRandomTurn = atIntersection && Math.random() < 0.55;

    if(!fwdOk || shouldRandomTurn){
      const nonReverse = valid.filter(d => !(d.dx===rev.dx && d.dy===rev.dy));
      const options = nonReverse.length ? nonReverse : valid;
      g.dir = options[(Math.random()*options.length)|0];
      return;
    }
    g.dir = fwd;
  }

  function moveGhost(g, dt){
    chooseGhostDir(g);
    const nx=g.x + g.dir.dx*ghostSpeed*dt;
    const ny=g.y + g.dir.dy*ghostSpeed*dt;

    if(!circleHitsWall(nx,ny,g.r)){
      g.x=nx; g.y=ny;
    } else {
      g.dir = {dx:-g.dir.dx, dy:-g.dir.dy};
    }
  }

  // =========================
  // GAME EVENTS
  // =========================
  function openGateIfReady(){
    if(collected>=TOTAL_ITEMS_PER_LEVEL) setGateOpen(true);
  }

  function openLevel2Intro(){
    awaitingLevel2Start = true;
    pendingMazeStartLevel = 2;
    paused = true;
    setMissionPanelForLevel(2);
    showLayer(missionLayer);
    setMusicVolume("mission");
    turnOnParticles();
  }

  function tryGateTransition(){
    const g=findGate();
    if(!g) return;
    if(map[g.r][g.c]!==4) return;

    const gx=(g.c+0.5)*tileSize, gy=(g.r+0.5)*tileSize;
    if(Math.hypot(player.x-gx, player.y-gy) < tileSize*0.6){
      if(level===1){
        openLevel2Intro();
      } else {
        triggerCongrats();
      }
    }
  }

  function checkItemCollisions(){
    for(const it of items){
      if(it.collected) continue;
      if(Math.hypot(player.x-it.x, player.y-it.y) < player.r+it.r){
        it.collected=true;
        collected++;
        saveItemFlags();
        updateHUD();

        if(level===1) showClueModal(it.id);
        else showLevel2Modal(it.id);

        openGateIfReady();
        break;
      }
    }
  }

  function checkGhostCollisions(){
    for(const g of ghosts){
      if(Math.hypot(player.x-g.x, player.y-g.y) < player.r+g.r-2){
        lives--;
        updateHUD();

        if(lives<=0){
          showModal({
            title:"üí• Game Over",
            bodyHTML:`<p>You ran out of lives.</p><p class="small">Click <b>Done</b> to restart from Level 1.</p>`,
            doneEnabled:true,
            onDone:()=>{ lives=3; startLevel(1, true); }
          });
          return;
        }

        resetPlayer();
        spawnGhosts();
        break;
      }
    }
  }

  // =========================
  // DRAW (maze + items + sprites)
  // =========================
  function drawMap(){
    for(let r=0;r<ROWS;r++){
      const row=map[r];
      for(let c=0;c<COLS;c++){
        const v=row[c];
        const x=c*tileSize, y=r*tileSize;

        if(v===1){
          gctx.fillStyle="rgba(27,66,255,0.95)";
          gctx.fillRect(x,y,tileSize,tileSize);
          gctx.fillStyle="rgba(255,255,255,0.06)";
          gctx.fillRect(x+2,y+2,tileSize-4,tileSize-4);
        } else {
          gctx.fillStyle=((r+c)&1) ? "rgba(9,9,18,1)" : "rgba(11,11,20,1)";
          gctx.fillRect(x,y,tileSize,tileSize);
        }

        // gate tile
        if(v===3||v===4){
          gctx.fillStyle=(v===3) ? "rgba(255,215,0,0.95)" : "rgba(47,225,122,0.85)";
          gctx.fillRect(x+2,y+2,tileSize-4,tileSize-4);
          gctx.fillStyle="rgba(0,0,0,0.35)";
          gctx.fillRect(x+6,y+6,tileSize-12,tileSize-12);
        }
      }
    }
  }

  function drawMagnifyingGlass(x,y){
    gctx.save();
    gctx.translate(x,y);
    gctx.strokeStyle="rgba(255,255,255,0.95)";
    gctx.lineWidth=2.2;
    gctx.beginPath(); gctx.arc(0,0,7.5,0,Math.PI*2); gctx.stroke();
    gctx.strokeStyle="rgba(255,255,255,0.85)";
    gctx.lineWidth=3.0;
    gctx.beginPath(); gctx.moveTo(6,6); gctx.lineTo(12,12); gctx.stroke();
    gctx.restore();
  }

  function drawHeartIcon(x,y){
    gctx.save();
    gctx.translate(x,y);
    gctx.scale(0.7,0.7);
    gctx.beginPath();
    gctx.moveTo(0,6);
    gctx.bezierCurveTo(0,-2,-12,-2,-12,6);
    gctx.bezierCurveTo(-12,14,0,18,0,26);
    gctx.bezierCurveTo(0,18,12,14,12,6);
    gctx.bezierCurveTo(12,-2,0,-2,0,6);
    gctx.closePath();
    gctx.fillStyle="#ff4fb3";
    gctx.fill();
    gctx.restore();
  }

  function drawItems(){
    for(const it of items){
      if(it.collected) continue;
      if(it.kind==="glass") drawMagnifyingGlass(it.x,it.y);
      else drawHeartIcon(it.x,it.y);
    }
  }

  function drawPlayer(){
    const angle=Math.atan2(player.dy||player.nextDy||0, player.dx||player.nextDx||1);
    const mouth=0.35 + 0.18*Math.sin(anim*0.18);
    gctx.save();
    gctx.translate(player.x,player.y);
    gctx.beginPath();
    gctx.moveTo(0,0);
    gctx.arc(0,0,player.r+2, angle+mouth, angle+(Math.PI*2-mouth));
    gctx.closePath();
    gctx.fillStyle="#ff4fb3";
    gctx.fill();
    gctx.beginPath(); gctx.arc(4,-4,2.1,0,Math.PI*2);
    gctx.fillStyle="rgba(255,255,255,.92)"; gctx.fill();
    gctx.restore();
  }

  function drawGhost(g){
    // pupils follow direction a bit
    const px=clamp(g.dir.dx*1.6,-1.6,1.6);
    const py=clamp(g.dir.dy*1.6,-1.6,1.6);
    drawGhostSprite(gctx, g.x, g.y, g.wiggle, g.shade, 1.0, px, py);
  }

  function drawGame(){
    gctx.fillStyle="#06060f";
    gctx.fillRect(0,0,gameCanvas.width,gameCanvas.height);
    drawMap();
    drawItems();
    drawPlayer();
    ghosts[0].wiggle += 0.2; ghosts[1].wiggle += 0.2;
    drawGhost(ghosts[0]);
    drawGhost(ghosts[1]);
  }

  // =========================
  // LEVEL START
  // =========================
  function ensureGateReachable(){
    const pr=(player.y/tileSize)|0, pc=(player.x/tileSize)|0;
    const dist=bfsDist(pr,pc);
    const g=findGate();
    if(g && dist[g.r][g.c]===-1){
      for(let r=pr;r<=g.r;r++){
        if(map[r][pc]===1) map[r][pc]=0;
      }
      map[g.r][g.c]=3;
    }
  }

  function startLevel(n, doFade){
    hasWon=false;
    awaitingLevel2Start = false;

    level=n;
    map = buildLevelMaze(level);

    fitGame();
    resetPlayer();
    ensureGateReachable();
    spawnGhosts();
    placeItems();
    updateHUD();

    if(doFade){
      fadeTo(()=>{ showLayer(gameLayer); setProgress(Progress.GAME_STARTED); setMusicVolume("game"); });
    }
  }

  // =========================
  // CONFETTI (stable + simple)
  // =========================
  function startConfetti(){
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
    confettiCanvas.style.display = "block";

    confetti = [];
    for(let i=0;i<240;i++){
      confetti.push({
        x: Math.random()*confettiCanvas.width,
        y: -Math.random()*confettiCanvas.height,
        vy: 2 + Math.random()*4,
        vx: -1 + Math.random()*2,
        s: 2 + Math.random()*4,
        a: Math.random()*Math.PI*2,
        va: -0.2 + Math.random()*0.4,
        color: confettiColors[(Math.random()*confettiColors.length)|0],
      });
    }
    confettiRunning = true;
  }
  function drawConfetti(){
    if(!confettiRunning) return;
    cctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
    for(const p of confetti){
      p.x += p.vx;
      p.y += p.vy;
      p.a += p.va;

      if(p.y > confettiCanvas.height + 20){
        p.y = -20;
        p.x = Math.random()*confettiCanvas.width;
      }
      if(p.x < -30) p.x = confettiCanvas.width + 30;
      if(p.x > confettiCanvas.width + 30) p.x = -30;

      cctx.save();
      cctx.translate(p.x,p.y);
      cctx.rotate(p.a);
      cctx.fillStyle = p.color;
      cctx.fillRect(-p.s, -p.s/2, p.s*2.2, p.s);
      cctx.restore();
    }
  }

  // =========================
  // CONGRATS -> ENDING CUTSCENES
  // =========================
  function triggerCongrats(){
    if(hasWon) return;
    hasWon=true;
    paused=true;

    winOverlay.style.display = "grid";
    startConfetti();

    continueBtn.onclick = () => {
      winOverlay.style.display = "none";
      confettiRunning=false;
      confettiCanvas.style.display="none";
      cctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);

      setProgress(Progress.ENDING);
      startEndingCutscenes();
    };
  }

  // =========================================================
  // ENDING CUTSCENES (slow + gate text on gate + minecraft-ish trees)
  // =========================================================
  const ending = {
    mode: "off",
    phase: "approachGate",
    t0: 0,

    pink: {x:-120, y:0, facing:0, r:18},
    blue: {x:0, y:0, facing:Math.PI, r:18},
    gate: {x:0, y:0, openAmt:0},

    lines: [],
    lineIndex: -1,
    showBubbleFrom: null,
    bubbleText: "",
    nextLineAt: 0,

    heart: {active:false, x:0,y:0, r:16, hover:false, pulse:0, clickable:false},
    floatingHearts: [],
    floatingHeartHover: -1,
    floatingHeartCooldownUntil: 0,
    celebrationTimer: null,
    inviteTimer: null,
    fade: 0
  };

  function seedFloatingHearts(count=7){
    const w = endingCanvas.width;
    const h = endingCanvas.height;
    ending.floatingHearts = Array.from({length:count}, (_, i)=>({
      x: Math.random() * w,
      y: h*(0.18 + Math.random()*0.46),
      r: 13 + Math.random()*8,
      driftX: (Math.random()*2 - 1) * 0.65,
      driftY: 0.18 + Math.random()*0.35,
      pulse: Math.random()*Math.PI*2,
      phase: Math.random()*Math.PI*2,
      twinkle: 0.45 + Math.random()*0.55,
      id: i
    }));
    ending.floatingHeartHover = -1;
  }

  function drawFloatingHearts(now, w, h){
    if(!ending.floatingHearts.length) seedFloatingHearts(7);
    ending.floatingHearts.forEach((heart, idx)=>{
      heart.pulse += 0.03;
      heart.phase += 0.008;
      heart.x += heart.driftX + Math.sin(heart.phase + idx)*0.04;
      heart.y -= heart.driftY * 0.42;

      if(heart.y < -40){
        heart.y = h + 28 + Math.random()*40;
        heart.x = Math.random() * w;
      }
      if(heart.x < -36) heart.x = w + 36;
      if(heart.x > w + 36) heart.x = -36;

      const hover = idx===ending.floatingHeartHover;
      const pulseScale = 1 + 0.09*Math.sin(heart.pulse);
      const hoverScale = hover ? 1.16 : 1;
      const scale = pulseScale * hoverScale;

      ectx.save();
      ectx.translate(heart.x, heart.y + Math.sin(heart.phase*2.2)*2.5);
      ectx.scale(scale, scale);
      ectx.shadowColor = hover ? "rgba(255,120,220,0.95)" : "rgba(255,79,179,0.75)";
      ectx.shadowBlur = hover ? 28 : 20;
      ectx.beginPath();
      ectx.moveTo(0,6);
      ectx.bezierCurveTo(0,-2,-12,-2,-12,6);
      ectx.bezierCurveTo(-12,14,0,18,0,26);
      ectx.bezierCurveTo(0,18,12,14,12,6);
      ectx.bezierCurveTo(12,-2,0,-2,0,6);
      ectx.closePath();
      const alpha = 0.56 + 0.34*Math.sin(now*0.002 + heart.twinkle);
      ectx.fillStyle = hover ? `rgba(255,150,223,${Math.min(0.98, alpha+0.12)})` : `rgba(255,79,179,${alpha})`;
      ectx.fill();
      ectx.restore();
    });
  }

  function drawMeadowBackground(w,h){
    ectx.fillStyle="#f7f7ff";
    ectx.fillRect(0,0,w,h);
    const groundY = Math.floor(h*0.70);
    ectx.fillStyle="#ffffff";
    ectx.fillRect(0, groundY, w, h-groundY);

    ectx.strokeStyle="rgba(10,10,20,0.04)";
    ectx.lineWidth=1;
    const spacing=48;
    for(let y=0; y<h; y+=spacing){
      ectx.beginPath(); ectx.moveTo(0,y); ectx.lineTo(w,y); ectx.stroke();
    }
    for(let x=0; x<w; x+=spacing){
      ectx.beginPath(); ectx.moveTo(x,0); ectx.lineTo(x,h); ectx.stroke();
    }

    function block(x,y,s,fill,shade){
      ectx.fillStyle=fill;
      ectx.fillRect(x,y,s,s);
      ectx.fillStyle=shade;
      ectx.fillRect(x+2,y+2,s-4,s-4);
    }
    function tree(tx, ty, scale){
      const s=scale;
      for(let i=0;i<4;i++) block(tx, ty - i*s, s, "#8b5a2b", "rgba(255,255,255,0.10)");
      for(let r=-2;r<=2;r++){
        for(let c=-2;c<=2;c++){
          if(Math.abs(r)+Math.abs(c) > 4) continue;
          block(tx + c*s, ty - 4*s + r*s, s, "#2f8f4e", "rgba(255,255,255,0.10)");
        }
      }
    }

    const baseY = Math.floor(h*0.69);
    tree(Math.floor(w*0.18), baseY, 18);
    tree(Math.floor(w*0.82), baseY, 18);
    tree(Math.floor(w*0.32), baseY+8, 14);
    tree(Math.floor(w*0.68), baseY+8, 14);
  }

  function meadowTreeCenterX(w){
    return (w*0.32 + w*0.68) * 0.5;
  }

  function resetFinalOverlays(){
    [valOverlay, inviteOverlay, creditsOverlay].forEach(el=>{
      el.classList.remove("show");
      el.setAttribute("aria-hidden", "true");
    });
    endingTitle.style.display = "none";
    endingCanvas.style.cursor = "default";
  }

  function startEndingCutscenes(){
    startAudioOnce();
    setMusicVolume("ending");
    rampHumTo(audioOn ? 0.03 : 0.0001, 0.8);
    resetFinalOverlays();

    if(ending.celebrationTimer) clearTimeout(ending.celebrationTimer);
    if(ending.inviteTimer) clearTimeout(ending.inviteTimer);

    ending.mode="on";
    ending.phase="approachGate";
    ending.t0=performance.now();

    const w=endingCanvas.width, h=endingCanvas.height;
    const midY = h*0.55;

    ending.pink.x = -120;
    ending.pink.y = midY;
    ending.pink.facing = 0;

    ending.blue.x = w + 120;
    ending.blue.y = midY;
    ending.blue.facing = Math.PI;

    ending.gate.x = w*0.65;
    ending.gate.y = midY;
    ending.gate.openAmt = 0;

    ending.lines = [
      {from:"pink", text:"I thought I‚Äôd never make it‚Ä¶"},
      {from:"blue", text:"Me too‚Ä¶ Every day felt longer without you here."},
      {from:"pink", text:"You‚Äôre‚Ä¶ here."},
      {from:"blue", text:"But you did. You‚Äôre finally back."},
      {from:"pink", text:"It‚Äôs been too long. I‚Äôve missed this."},
      {from:"pink", text:"I would‚Äôve made it back sooner‚Ä¶ but those ghosts took my hearts and my memories right at the gate."},
      {from:"blue", text:"Did you get them all back?"},
      {from:"pink", text:"Yeah‚Ä¶ I did."},
      {from:"pink", text:"But it still feels incomplete."},
      {from:"pink", text:"Like I‚Äôm missing something."},
      {from:"blue", text:"Hmm‚Ä¶ maybe that‚Äôs because I‚Äôve been holding onto the last piece."},
      {from:"pink", text:"The last piece?"},
      {action:"spawnHeart"},
      {from:"blue", text:"I was waiting to give it to you."},
      {from:"pink", text:"Another heart?"},
      {from:"pink", text:"‚Ä¶What‚Äôs in it?"}
    ];

    ending.lineIndex=-1;
    ending.showBubbleFrom=null;
    ending.bubbleText="";
    ending.nextLineAt=0;

    ending.heart.active=false;
    ending.heart.hover=false;
    ending.heart.clickable=false;
    ending.heart.pulse=0;

    fadeTo(()=>{ showLayer(endingLayer); });
  }

  function advanceEndingDialogueAuto(now){
    ending.lineIndex++;
    const line = ending.lines[ending.lineIndex];
    if(!line){
      ending.phase = "heartAwaitClick";
      ending.bubbleText = "";
      ending.showBubbleFrom = null;
      ending.heart.clickable = true;
      return;
    }

    if(line.action === "spawnHeart"){
      ending.heart.active = true;
      ending.heart.clickable = false;
      ending.heart.pulse = 0;
      ending.heart.x = ending.blue.x - 10;
      ending.heart.y = ending.blue.y - 4;
      ending.bubbleText = "";
      ending.showBubbleFrom = null;
      ending.nextLineAt = now + 850;
      return;
    }

    ending.showBubbleFrom = line.from;
    ending.bubbleText = line.text;
    const delay = Math.max(1900, Math.min(3400, 950 + line.text.length * 28));
    ending.nextLineAt = now + delay;
  }

  function showValentineModal(){
    ending.phase = "valentineModal";
    valOverlay.style.display = "grid";
    requestAnimationFrame(()=> valOverlay.classList.add("show"));
    valOverlay.setAttribute("aria-hidden", "false");
  }

  function clampNoButtonPosition(left, top){
    const wrap = valBtnWrap.getBoundingClientRect();
    const btn = noValBtn.getBoundingClientRect();
    const min = 8;
    const maxLeft = Math.max(min, wrap.width - btn.width - min);
    const maxTop = Math.max(min, wrap.height - btn.height - min);
    return {
      left: clamp(left, min, maxLeft),
      top: clamp(top, min, maxTop)
    };
  }

  function dodgeNoButton(){
    const wrap = valBtnWrap.getBoundingClientRect();
    const btn = noValBtn.getBoundingClientRect();
    const targetLeft = Math.random() * Math.max(14, wrap.width - btn.width - 14);
    const targetTop = Math.random() * Math.max(14, wrap.height - btn.height - 14);
    const pos = clampNoButtonPosition(targetLeft, targetTop);
    noValBtn.style.left = `${pos.left}px`;
    noValBtn.style.top = `${pos.top}px`;
    noValBtn.style.transform = "scale(1.06)";
    setTimeout(()=>{ noValBtn.style.transform = "scale(1)"; }, 140);
  }

  function startCelebration(){
    valOverlay.classList.remove("show");
    setTimeout(()=>{
      valOverlay.style.display = "none";
      valOverlay.setAttribute("aria-hidden", "true");
    }, 420);

    ending.phase = "celebration";
    ending.t0 = performance.now();
    ending.heart.active = false;
    ending.heart.clickable = false;
    seedFloatingHearts();

    endingTitle.style.display = "block";
    startConfetti();
    ending.celebrationTimer = setTimeout(()=>{
      confettiRunning=false;
      confettiCanvas.style.display="none";
      cctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
    }, 5000);

    ending.inviteTimer = setTimeout(()=>{ showInvitation(); }, 2000);
  }

  function showInvitation(){
    inviteBody.textContent = `üç∑‚ú® Let‚Äôs go back to where it all began‚Ä¶ ‚ú®üåπ

üìç YOGU Restaurant
üóì 15 February 2025
‚è∞ 7:00 PM
üïØÔ∏è Table for Two
üåü Guest of Honor: My Love

üìã Criteria:
‚Ä¢ Show up
‚Ä¢ Look pretty as usual
‚Ä¢ Bring an appetite

üíñ I can‚Äôt wait to take you back to our first-date spot.`;
    inviteOverlay.style.display = "grid";
    requestAnimationFrame(()=>inviteOverlay.classList.add("show"));
    inviteOverlay.setAttribute("aria-hidden", "false");
  }

  function showCredits(){
    inviteOverlay.classList.remove("show");
    setTimeout(()=>{
      inviteOverlay.style.display = "none";
      inviteOverlay.setAttribute("aria-hidden", "true");
    }, 350);

    creditsInner.innerHTML = `
      <h3 style="margin:0 0 10px">Why this game matters</h3>
      <p>Ghosts represent negative emotions, self-doubt, and stress that steal good memories.</p>
      <p>The maze represents the messy journey of remembering what matters most.</p>
      <p>Hearts and memories represent rebuilding love and meaning one piece at a time.</p>
      <p>The final heart represents commitment and choosing each other, fully and intentionally.</p>
      <p style="margin-top:20px">Sorry I took so long with this, but I had to learn everything along the way to create all of this.</p>
      <p style="margin-top:26px; font-weight:1000">Made with love, for you.</p>
    `;

    creditsOverlay.style.display = "grid";
    requestAnimationFrame(()=>creditsOverlay.classList.add("show"));
    creditsOverlay.setAttribute("aria-hidden", "false");
    ending.phase = "credits";
  }

  function closeCreditsAndResumeCelebration(){
    creditsOverlay.classList.remove("show");
    setTimeout(()=>{
      creditsOverlay.style.display = "none";
      creditsOverlay.setAttribute("aria-hidden", "true");
    }, 320);

    ending.phase = "celebration";
    ending.t0 = performance.now();
    if(!confettiRunning) startConfetti();
    if(ending.celebrationTimer) clearTimeout(ending.celebrationTimer);
    ending.celebrationTimer = setTimeout(()=>{
      confettiRunning=false;
      confettiCanvas.style.display="none";
      cctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
    }, 6000);
  }

  yesValBtn.addEventListener("click", startCelebration);
  noValBtn.addEventListener("mouseenter", dodgeNoButton);
  noValBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); dodgeNoButton(); });
  valCard.addEventListener("pointermove", (e)=>{
    const b = noValBtn.getBoundingClientRect();
    const near = Math.hypot(e.clientX - (b.left+b.width/2), e.clientY - (b.top+b.height/2));
    if(near < 95) dodgeNoButton();
  });

  inviteContinueBtn.addEventListener("click", showCredits);
  creditsDoneBtn.addEventListener("click", closeCreditsAndResumeCelebration);

  function updateFloatingHeartPointer(e){
    const canInteract = ending.mode==="on"
      && endingLayer.classList.contains("active")
      && (ending.phase==="celebration" || ending.phase==="credits")
      && creditsOverlay.getAttribute("aria-hidden") !== "false"
      && modalOverlay.style.display !== "grid"
      && performance.now() >= ending.floatingHeartCooldownUntil;
    if(!canInteract || !ending.floatingHearts.length){
      ending.floatingHeartHover = -1;
      return -1;
    }

    const rect = endingCanvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (endingCanvas.width / rect.width);
    const my = (e.clientY - rect.top) * (endingCanvas.height / rect.height);

    let found = -1;
    for(let i=0;i<ending.floatingHearts.length;i++){
      const h = ending.floatingHearts[i];
      if(Math.hypot(mx - h.x, my - h.y) <= h.r * 1.15){
        found = i;
        break;
      }
    }
    ending.floatingHeartHover = found;
    return found;
  }

  function updateHeartPointer(e){
    if(ending.mode!=="on" || !ending.heart.active) return false;
    const rect = endingCanvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (endingCanvas.width / rect.width);
    const my = (e.clientY - rect.top) * (endingCanvas.height / rect.height);
    ending.heart.hover = (Math.hypot(mx-ending.heart.x, my-ending.heart.y) <= ending.heart.r*1.05);
    return ending.heart.hover;
  }

  endingCanvas.addEventListener("pointerdown", (e)=>{
    if(!updateHeartPointer(e) || !ending.heart.clickable) return;
    playHeartUnlockSfx();
    ending.heart.active=false;
    endingCanvas.style.cursor="default";
    showValentineModal();
  });

  endingCanvas.addEventListener("pointermove", (e)=>{
    const heartHover = updateHeartPointer(e);
    const floatingHover = updateFloatingHeartPointer(e);
    endingCanvas.style.cursor = (heartHover || floatingHover>=0) ? "pointer" : "default";
  });

  endingCanvas.addEventListener("pointerdown", (e)=>{
    const hitFloating = updateFloatingHeartPointer(e);
    if(hitFloating < 0) return;
    ending.floatingHeartCooldownUntil = performance.now() + 180;
    const randomIdx = Math.floor(Math.random() * level2Popups.length);
    showLevel2Modal(randomIdx);
  });

  function drawEndingFrame(now){
    if(!endingLayer.classList.contains("active") || ending.mode!=="on"){
      requestAnimationFrame(drawEndingFrame);
      return;
    }
    const w=endingCanvas.width, h=endingCanvas.height;

    if(ending.phase==="approachGate" || ending.phase==="gateOpen" || ending.phase==="enterGate" || ending.phase==="pauseAfterGateEnter" || ending.phase==="fadeToMeadow"){
      ectx.fillStyle="#05050a";
      ectx.fillRect(0,0,w,h);
      ectx.strokeStyle="rgba(27,66,255,0.12)";
      ectx.lineWidth=2;
      for(let y=48; y<h; y+=48){ ectx.beginPath(); ectx.moveTo(0,y); ectx.lineTo(w,y); ectx.stroke(); }
      for(let x=48; x<w; x+=48){ ectx.beginPath(); ectx.moveTo(x,0); ectx.lineTo(x,h); ectx.stroke(); }

      const midY = h*0.55;
      ending.pink.y = midY;
      ending.gate.y = midY;

      if(ending.phase==="approachGate"){
        const t = clamp((now-ending.t0)/1000 / 4.6, 0, 1);
        ending.pink.x = lerp(-120, ending.gate.x - 52, easeInOut(t));
        drawGateCard(ectx, ending.gate.x, ending.gate.y, "YOU MAY", "ENTER", 0, 0);
        drawDioPac(ectx, ending.pink.x, ending.pink.y, now, 0, "#ff4fb3", 18);
        if(t>=1){ ending.phase="gateOpen"; ending.t0=now; }
        requestAnimationFrame(drawEndingFrame); return;
      }

      if(ending.phase==="gateOpen"){
        const t = clamp((now-ending.t0)/1000 / 1.8, 0, 1);
        ending.gate.openAmt = easeInOut(t);
        drawGateCard(ectx, ending.gate.x, ending.gate.y, "YOU MAY", "ENTER", 0, ending.gate.openAmt);
        drawDioPac(ectx, ending.pink.x, ending.pink.y, now, 0, "#ff4fb3", 18);
        if(t>=1){ ending.phase="enterGate"; ending.t0=now; }
        requestAnimationFrame(drawEndingFrame); return;
      }

      if(ending.phase==="enterGate"){
        const t = clamp((now-ending.t0)/1000 / 2.6, 0, 1);
        ending.pink.x = lerp(ending.gate.x - 52, ending.gate.x + 6, easeInOut(t));
        drawGateCard(ectx, ending.gate.x, ending.gate.y, "YOU MAY", "ENTER", 0, 1);
        drawDioPac(ectx, ending.pink.x, ending.pink.y, now, 0, "#ff4fb3", 18);
        ectx.fillStyle=`rgba(0,0,0,${clamp((t-0.65)/0.35, 0, 1)})`;
        ectx.fillRect(0,0,w,h);
        if(t>=1){ ending.phase="pauseAfterGateEnter"; ending.t0=now; }
        requestAnimationFrame(drawEndingFrame); return;
      }

      if(ending.phase==="pauseAfterGateEnter"){
        ectx.fillStyle="#000";
        ectx.fillRect(0,0,w,h);
        if((now-ending.t0)/1000 > 1.2){ ending.phase="fadeToMeadow"; ending.t0=now; }
        requestAnimationFrame(drawEndingFrame); return;
      }

      if(ending.phase==="fadeToMeadow"){
        const t = clamp((now-ending.t0)/1000 / 1.2, 0, 1);
        drawMeadowBackground(w,h);
        ectx.fillStyle=`rgba(0,0,0,${1-easeOut(t)})`;
        ectx.fillRect(0,0,w,h);
        if(t>=1){
          ending.phase="meadowWalk";
          ending.t0=now;
          ending.gate.x = w*0.22;
          ending.gate.y = h*0.55;
          ending.gate.openAmt = 1;
          ending.pink.x = ending.gate.x + 8;
          ending.pink.y = ending.gate.y;
          ending.blue.x = w + 140;
          ending.blue.y = ending.gate.y;
        }
        requestAnimationFrame(drawEndingFrame); return;
      }
    }

    if(["meadowWalk","meetApproach","meetDialogueAuto","heartAwaitClick","valentineModal","celebration","credits"].includes(ending.phase)){
      drawMeadowBackground(w,h);
      drawGateCard(ectx, ending.gate.x, ending.gate.y, "", "", 0, 1);

      if(ending.phase==="meadowWalk"){
        const t = clamp((now-ending.t0)/1000 / 2.4, 0, 1);
        const pinkMeetX = meadowTreeCenterX(w) - 21;
        ending.pink.x = lerp(ending.gate.x + 8, pinkMeetX, easeInOut(t));
        drawDioPac(ectx, ending.pink.x, ending.pink.y, now, 0, "#ff4fb3", 18);
        if(t>=1){ ending.phase="meetApproach"; ending.t0=now; }
        requestAnimationFrame(drawEndingFrame); return;
      }

      if(ending.phase==="meetApproach"){
        const t = clamp((now-ending.t0)/1000 / 4.6, 0, 1);
        ending.blue.x = lerp(w+140, meadowTreeCenterX(w) + 21, easeInOut(t));
        drawDioPac(ectx, ending.pink.x, ending.pink.y, now, 0, "#ff4fb3", 18);
        drawDioPac(ectx, ending.blue.x, ending.blue.y, now, Math.PI, "#3aa0ff", 18);
        if(t>=1){
          ending.phase="meetDialogueAuto";
          ending.t0=now;
          ending.lineIndex=-1;
          advanceEndingDialogueAuto(now);
        }
        requestAnimationFrame(drawEndingFrame); return;
      }

      const celebratoryPhase = (ending.phase==="celebration" || ending.phase==="credits");
      const bounce = celebratoryPhase ? Math.sin(now*0.012)*8 : 0;
      drawDioPac(ectx, ending.pink.x, ending.pink.y + bounce, now, 0, "#ff4fb3", 18);
      drawDioPac(ectx, ending.blue.x, ending.blue.y + bounce, now, Math.PI, "#3aa0ff", 18);

      if(celebratoryPhase){
        drawFloatingHearts(now, w, h);
      }

      if(ending.phase==="meetDialogueAuto"){
        if(ending.bubbleText){
          const bx = ending.showBubbleFrom==="blue" ? ending.blue.x : ending.pink.x;
          const by = ending.showBubbleFrom==="blue" ? ending.blue.y : ending.pink.y;
          drawSpeechBubble(ectx, bx, by, ending.bubbleText);
        }

        if(ending.heart.active){
          ending.heart.pulse += 0.05;
          const targetX = (ending.pink.x + ending.blue.x)/2;
          const targetY = ending.pink.y - 120 + Math.sin(now*0.006)*4;
          ending.heart.x = lerp(ending.heart.x, targetX, 0.06);
          ending.heart.y = lerp(ending.heart.y, targetY, 0.06);

          const hoverScale = ending.heart.hover ? 1.12 : 1;
          const pulseScale = 1 + 0.07*Math.sin(ending.heart.pulse);
          ectx.save();
          ectx.translate(ending.heart.x, ending.heart.y);
          ectx.scale(pulseScale*hoverScale, pulseScale*hoverScale);
          ectx.shadowColor="rgba(255,79,179,0.65)";
          ectx.shadowBlur=18 + (ending.heart.hover ? 12 : 0);
          ectx.beginPath();
          ectx.moveTo(0,6);
          ectx.bezierCurveTo(0,-2,-12,-2,-12,6);
          ectx.bezierCurveTo(-12,14,0,18,0,26);
          ectx.bezierCurveTo(0,18,12,14,12,6);
          ectx.bezierCurveTo(12,-2,0,-2,0,6);
          ectx.closePath();
          ectx.fillStyle = ending.heart.hover ? "#ff7bc9" : "#ff4fb3";
          ectx.fill();
          ectx.restore();
        }

        if(now >= ending.nextLineAt){
          advanceEndingDialogueAuto(now + 380);
        }
      }

      if(ending.phase==="heartAwaitClick"){
        ending.heart.pulse += 0.06;
        const targetX = (ending.pink.x + ending.blue.x)/2;
        const targetY = ending.pink.y - 120 + Math.sin(now*0.006)*4;
        ending.heart.x = targetX;
        ending.heart.y = targetY;

        ectx.save();
        ectx.translate(ending.heart.x, ending.heart.y);
        const hoverScale = ending.heart.hover ? 1.15 : 1;
        const pulseScale = 1 + 0.08*Math.sin(ending.heart.pulse);
        ectx.scale(pulseScale*hoverScale, pulseScale*hoverScale);
        ectx.shadowColor="rgba(255,79,179,0.75)";
        ectx.shadowBlur=22;
        ectx.beginPath();
        ectx.moveTo(0,6);
        ectx.bezierCurveTo(0,-2,-12,-2,-12,6);
        ectx.bezierCurveTo(-12,14,0,18,0,26);
        ectx.bezierCurveTo(0,18,12,14,12,6);
        ectx.bezierCurveTo(12,-2,0,-2,0,6);
        ectx.closePath();
        ectx.fillStyle="#ff4fb3";
        ectx.fill();
        ectx.restore();

        ectx.save();
        ectx.fillStyle="rgba(15,16,34,0.8)";
        ectx.strokeStyle="rgba(255,255,255,.2)";
        roundRect(ectx, w*0.5-164, h*0.10, 328, 40, 13);
        ectx.fill(); ectx.stroke();
        ectx.fillStyle="#fff";
        ectx.font="900 15px system-ui";
        ectx.textAlign="center";
        ectx.fillText("CLICK THE HEART", w*0.5, h*0.10 + 25);
        ectx.restore();
      }

      requestAnimationFrame(drawEndingFrame); return;
    }

    requestAnimationFrame(drawEndingFrame);
  }

  // =========================================================
  // GAME LOOP
  // =========================================================
  function step(now){
    const dt=(now-lastT)/1000;
    lastT=now;
    acc += clamp(dt,0,0.06);

    let sub=0;
    while(acc>=fixedDt && sub<maxSubSteps){
      if(gameLayer.classList.contains("active") && !paused){
        movePlayer(fixedDt);
        moveGhost(ghosts[0], fixedDt);
        moveGhost(ghosts[1], fixedDt);
        checkItemCollisions();
        checkGhostCollisions();
        tryGateTransition();
      }
      acc-=fixedDt;
      sub++;
    }

    anim++;
    if(gameLayer.classList.contains("active")){
      drawGame();
    }
    drawConfetti();

    requestAnimationFrame(step);
  }

  // =========================================================
  // BUTTONS
  // =========================================================
  function startSelectedMaze(){
    startAudioOnce();
    setMusicVolume("game");
    rampHumTo(audioOn ? 0.05 : 0.0001, pendingMazeStartLevel===2 ? 0.8 : 1.2);

    if(pendingMazeStartLevel===2){
      awaitingLevel2Start = false;
      paused = false;
      clearItemFlagsForLevel(2);
      localStorage.setItem(COLLECT_KEY, "0");
      startLevel(2, true);
      return;
    }

    setMissionPanelForLevel(1);
    startLevel(1, true);
  }

  rulesBtn.addEventListener("click",()=>{
    startAudioOnce();
    alert(
      "Level 1: collect 5 magnifying glasses and answer each memory question.\n" +
      "Level 2: collect 5 hearts (each shows a popup).\n" +
      "After that: Continue ‚Üí gate opens ‚Üí new map with trees ‚Üí heart click ‚Üí Valentine popup."
    );
  });

  letsGoBtn.addEventListener("click", ()=>{
    startSelectedMaze();
  });

  resetBtn.addEventListener("click",()=>{
    resetAllPersistent();
    location.reload();
  });

  // =========================================================
  // BOOT
  // =========================================================
  progressText.textContent = getProgress();

  function boot(){
    const p = getProgress();

    requestAnimationFrame(particlesLoop);
    requestAnimationFrame(step);
    requestAnimationFrame(drawEndingFrame);

    if(p === Progress.NEW){
      showLayer(introLayer);
      setMusicVolume("intro");
      hideIntroBottom();
      requestAnimationFrame(runIntroFrame);
      return;
    }

    if(p === Progress.INTRO_DONE || p === Progress.MISSION_SHOWN){
      pendingMazeStartLevel = 1;
      setMissionPanelForLevel(1);
      showLayer(missionLayer);
      setMusicVolume("mission");
      setTimeout(()=>{ turnOnParticles(); }, 100);
      return;
    }

    if(p === Progress.GAME_STARTED){
      showLayer(gameLayer);
      startAudioOnce();
      setMusicVolume("game");
      rampHumTo(audioOn ? 0.05 : 0.0001, 0.7);

      // resume level
      map = buildLevelMaze(level);
      fitGame();
      resetPlayer();
      ensureGateReachable();
      spawnGhosts();
      placeItems();
      updateHUD();
      return;
    }

    if(p === Progress.ENDING){
      startEndingCutscenes();
      return;
    }

    pendingMazeStartLevel = 1;
    setMissionPanelForLevel(1);
    showLayer(missionLayer);
    setMusicVolume("mission");
    setTimeout(()=>{ turnOnParticles(); }, 100);
  }

  // Start gameplay input can also start audio
  window.addEventListener("pointerdown", startAudioOnce, {once:true});

  // Kick off intro loop (only visible if introLayer active)
  requestAnimationFrame(runIntroFrame);

  boot();
})();
</script>
</body>
</html>
